% vim: set filetype=tex :
% Note: every acronym is listed twice: once so it can be expanded, and once
% so it will appear with a long description in the glossary.
% Warning: do not use acronyms within definitions, they do not work
% properly.

\newglossaryentry{PLP}{
    type=\acronymtype,
    name={PLP},
    description={Postfix Log Parser},
    first={Postfix Log Parser (PLP)}
}

\newglossaryentry{regex}{
    type=\acronymtype,
    name={regex},
    description={Regular Expression},
    first={Regular Expression (regex)}
}
\newcommand{\regexglossarydescription}[0]{
    Regular Expressions are a compact, powerful method of specifying
    patterns that describe a set of strings.  The regex \texttt{aa*b*b}
    describes a set of strings, all of which start with \texttt{a},
    followed by any number of \texttt{a}, then any number of \texttt{b},
    and finish with \texttt{b}; the strings \texttt{ab},
    \texttt{aaaaaaaab}, and \texttt{aaabbbbb} are members of that set,
    whereas the strings \texttt{abba}, \texttt{abcd}, and \texttt{qwerty}
    are not.  A string can be checked against a regex to determine if the
    string is a member of the set of strings described by that regex.
}
\newglossaryentry{regex glossary}{
    name={Regular Expression},
    description={
        \regexglossarydescription{}%
    }
}

\newglossaryentry{DNSBL}{
    type=\acronymtype,
    name={DNSBL},
    description={DNS Blacklist},
    first={DNS Blacklist (DNSBL)}
}
\newglossaryentry{DNSBL glossary}{
    name={DNS Blacklist},
    description={
        A \acronym{DNSBL} is a simple collaborative anti-spam technique
        used to reject or penalise mail sent from IP addresses believed to
        be the source of large volumes of spam.  The criteria used when
        deciding if an IP address should be included vary widely between
        \acronym[s]{DNSBL}, so before using one it is essential to check
        their listing policies.  To use a \acronym{DNSBL}, Postfix makes a
        DNS request incorporating the IP address of the client; if the
        requested hostname is found the client is on the \acronym{DNSBL}.
    }
}

\newglossaryentry{API}{
    type=\acronymtype,
    name={API},
    description={Application Programming Interface},
    first={Application Programming Interface (API)}
}
\newglossaryentry{API glossary}{
    name={Application Programming Interface},
    description={
        One of the fundamental concepts when writing programs is the reuse
        of existing code, so that each new program does not reinvent
        existing wheels.  An \acronym{API} defines the interface provided
        to the user of the existing code, and acts as a contract between
        the user and the provider: if the user adheres to the \acronym{API}
        the provider guarantees it will work, but is free to change the
        underlying implementation if the \acronym{API} is preserved.
    }
}

\newglossaryentry{SMTP}{
    type=\acronymtype,
    name={SMTP},
    description={Simple Mail Transfer Protocol},
    first={Simple Mail Transfer Protocol (SMTP)}
}
\newcommand{\SMTPglossaryDescription}[0]{%
    \glsreset{SMTP}\acronym{SMTP} is the protocol used for transferring
    mail between the sending and receiving \acronym{MTA}\@.  It is a
    simple, human readable, plain text protocol, making it quite simple to
    test and debug problems with it.  A detailed description of
    \acronym{SMTP} is beyond the scope of this thesis: the original
    protocol definition is in \acronym{RFC}~821~\cite{RFC821}, later
    superceded by \acronym{RFC}~2821~\cite{RFC2821}.%
}
\newglossaryentry{SMTP glossary}{
    name={Simple Mail Transfer Protocol},
    description={
        \SMTPglossaryDescription{}
    }
}

\newglossaryentry{LMTP}{
    type=\acronymtype,
    name={LMTP},
    description={Local Mail Transfer Protocol},
    first={Local Mail Transfer Protocol (LMTP)}
}
\newglossaryentry{LMTP glossary}{
    name={Local Mail Transfer Protocol},
    description={
        \acronym{LMTP} is a protocol derived from \acronym{SMTP} that
        removes the need for the server to maintain a mail delivery queue,
        instead relying on the client to maintain it.  Typically the client
        is an \acronym{MTA}, and the server is a delivery agent or a mail
        store.  Full details are available in~\cite{lmtp-rfc}.
    }
}

\newglossaryentry{MTA}{
    type=\acronymtype,
    name={MTA},
    description={Mail Transfer Agent},
    first={Mail Transfer Agent (MTA)}
}
\newglossaryentry{MTA glossary}{
    name={Mail Transfer Agent},
    description={
        \glsreset{MTA}A \acronym{MTA} sends and receives mail via
        \acronym{SMTP}\@.  Users submit mail to an \acronym{MTA} via their
        mail client (e.g.\ Microsoft Outlook, Thunderbird, webmail
        services); the sending \acronym{MTA} transfers the mail to the
        receiving \acronym{MTA}, which forwards the mail to another
        recipient, or delivers the mail to a user's mailbox or a program
        such as a mailing list manager.
    }
}

\newglossaryentry{RFC}{
    type=\acronymtype,
    name={RFC},
    description={Request For Comments},
    first={Request For Comments (RFC)}
}
\newglossaryentry{RFC glossary}{
    name={Request For Comments},
    description={
        \glsreset{RFC}The \acronym{RFC} series is a series of proposals
        defining various protocols and formats, e.g.\ \acronym{SMTP}\@.
        The name is somewhat misleading nowadays: initially the authors
        were asking for peer review, but these documents are now the de
        facto standards the Internet runs on.
    }
}

\newglossaryentry{SQL}{
    type=\acronymtype,
    name={SQL},
    description={Structured Query Language},
    first={Structured Query Language (SQL)}
}

\newglossaryentry{LMA}{
    type=\acronymtype,
    name={LMA},
    description={Log Mail Analyzer},
    first={Log Mail Analyzer (LMA)}
}

\newglossaryentry{CSV}{
    type=\acronymtype,
    name={CSV},
    description={Comma-Separated Value},
    first={Comma-Separated Value (CSV)}
}

\newglossaryentry{FQDN}{
    type=\acronymtype,
    name={FQDN},
    description={Fully Qualified Domain Name},
    first={Fully Qualified Domain Name (FQDN)}
}
\newglossaryentry{FQDN glossary}{
    name={Fully Qualified Domain Name},
    description={
        An \acronym{FQDN} is a hostname plus domain name, e.g.\ \newline{}
            example.com     is a domain name                    \newline{}
            www             is a hostname                       \newline{}
            www.example.com is a \acronym{FQDN}
    }
}

\newglossaryentry{pid}{
    type=\acronymtype,
    name={pid},
    description={Process Identifier},
    first={Process Identifier (pid)}
}
\newglossaryentry{pid glossary}{
    name={Process Identifier},
    description={
        There may be multiple copies of any program executing at any one
        time, so the program's name is not suitable as a distinguishing
        identifier; instead, each process is given a \acronym{pid} that is
        guaranteed to be unique for the lifetime of the process.  Once the
        process has completed, the \acronym{pid} may be reused, because
        they are drawn from a finite pool.
    }
}

\newglossaryentry{UCE}{
    type=\acronymtype,
    name={UCE},
    description={Unsolicited Commercial Email},
    first={Unsolicited Commercial Email (UCE)}
}
\newglossaryentry{UCE glossary}{
    name={Unsolicited Commercial Email},
    description={
        \acronym{UCE} is a more restrictive definition of spam than most
        people use: it only covers mail that is explicitly commercial, thus
        excluding viruses, Bayesian poisoning mails,
        backscatter\glsadd{Backscatter}, and those annoying chain letters
        you get from friends.
    }
}

\newglossaryentry{ESMTP}{
    type=\acronymtype,
    name={ESMTP},
    description={Extended SMTP},
    first={Extended SMTP (ESMTP)}
}
\newglossaryentry{ESMTP glossary}{
    name={Extended SMTP},
    description={
        \acronym{ESMTP}~\cite{RFC1869} provides a flexible mechanism for
        \acronym{SMTP} to be extended with new functionality, allowing new
        features to be tested without having to be included in the standard
        protocol.  \acronym{ESMTP} is backwards compatible with
        \acronym{SMTP}: \acronym{ESMTP} clients and servers can interact
        with \acronym{SMTP} clients and servers without difficulty.
    }
}

\newglossaryentry{SLCT}{
    type=\acronymtype,
    name={SLCT},
    description={Simple Logfile Clustering Tool},
    first={Simple Logfile Clustering Tool (SLCT)}
}

\newglossaryentry{ATN}{
    type=\acronymtype,
    name={ATN},
    description={Augmented Transition Networks},
    first={Augmented Transition Networks (ATN)}
}

\newglossaryentry{CLI}{
    type=\acronymtype,
    name={CLI},
    description={Command Line Interface},
    first={Command Line Interface (CLI)}
}

\newglossaryentry{NLP}{
    type=\acronymtype,
    name={NLP},
    description={Natural Language Processing},
    first={Natural Language Processing (NLP)}
}
\newglossaryentry{NLP glossary}{
    name={Natural Language Processing},
    description={
        Natural Language Processing is an area of research that attempts to
        increase our understanding of the languages normally used by humans
        (e.g.\ English, Spanish, Japanese), with the goal of writing
        programs that can understand human languages.
    }
}

\newglossaryentry{FA}{
    type=\acronymtype,
    name={FA},
    description={Finite Automata},
    first={Finite Automata (FA)}
}
\newglossaryentry{FA glossary}{
    name={Finite Automata},
    description={
        \acronym{FA} are computing devices that accept or recognize
        regular languages.  They lack any form of storage, so although they
        can recognise languages such as ${(ab)}^{*}$ or
        $a^{*}{(b^{*}|c)}b$, they cannot count and so cannot recognise
        languages such as $a^{n}b^{n}$.
    }
}

\newglossaryentry{CFG}{
    type=\acronymtype,
    name={CFG},
    description={Context Free Grammar},
    first={Context Free Grammar (CFG)}
}
\newglossaryentry{CFG glossary}{
    name={Context Free Grammar},
    description={
        A \acronym{CFG} is a grammar in which every transition or
        production takes the form $L\rightarrow{}R$, where $L$ is a single
        non-terminal symbol, and $R$ is a (possibly empty) string of
        terminal or non-terminal symbols.  Every \acronym{CFG} can be
        recognised by a \acronym{PDA}, and \acronyms{PDA} cannot recognise
        more complicated grammars, so \acronyms{CFG} and \acronyms{PDA} are
        equivalent in computational power.
    }
}

\newglossaryentry{PDA}{
    type=\acronymtype,
    name={PDA},
    description={Push-Down Automata},
    first={Push-Down Automata (PDA)}
}
\newglossaryentry{PDA glossary}{
    name={Push-Down Automata},
    description={
        \glsreset{PDA}A \acronym{PDA} is a computational device similar to
        a \acronym{FA}, but it can additionally use a stack to store data.
        A \acronym{PDA} can manipulate the stack during state transitions
        by adding or removing a single piece of data, and when determining
        which state transition to take, the piece of data on the top of the
        stack can be used in addition to the input.  \acronym{PDA} can
        recognise all the languages recognised by \acronym{FA}, and can
        also recognised languages of the form $a^{n}b^{n}$.
    }
}

\newglossaryentry{SPF}{
    type=\acronymtype,
    name={SPF},
    description={Sender Policy Framework},
    first={Sender Policy Framework (SPF)}
}

%\newglossaryentry{}{
%    type=\acronymtype,
%    name={},
%    description={},
%    first={}
%}
%\newglossaryentry{}{
%    name={},
%    description={
%    }
%}
