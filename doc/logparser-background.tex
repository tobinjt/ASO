\section{Background}

\label{background}

This section provides background information helpful in understanding the
remainder of the thesis.  It begins with a discussion of the motivation
underlying the project, followed by some technical information: the use of
a database as an \gls{API}\@; a brief introduction to \gls{SMTP}\@.  It
finishes with a longer introduction to Postfix, concentrating on anti-spam
restrictions and policy servers.

\subsection{Motivation}

\label{motivation}

This thesis and the program it describes are part of a larger project to
optimise a mail server's Postfix-based anti-spam restrictions, generate
statistics and graphs, and provide a platform on which new restrictions on
trial can be evaluated to determine if they are beneficial in the fight
against spam.  The program parses Postfix log files and populates a
database with the data gleaned from those log files, providing a consistent
and simple view of the log files that future tools can utilise.  The
gathered data can be used to optimise current anti-spam measures, to
provide a baseline to test new anti-spam measures against, or to produce
statistics showing how effective those measures are.

Determining which Postfix restrictions reject the highest number of mails
is a short example of the optimisation possible using data from the
database:

\begin{verbatim}
SELECT name, description, restriction_name, hits_total
    FROM rules
    WHERE postfix_action = 'REJECTED'
    ORDER BY hits_total DESC;
\end{verbatim}

If the database supports sub-selects (where the results of one query are
used in another), percentages can be obtained for the top ten restrictions
(sample output shown in \tableref{Sample output from SQL query showing
percentages}):

\input{build/include-sample-sql-query}

\begin{table}[ht]
    \caption{Sample output from SQL query showing percentages}
    \empty{}\label{Sample output from SQL query showing
    percentages}
    \begin{tabular}[]{lrr}
        \tabletopline{}%
        Restriction & Number of hits & Percentage of hits \\
        \tablemiddleline{}%
        \input{build/include-sample-sql-output}
        \tablebottomline{}%
    \end{tabular}
\end{table}


Another example is determining which restrictions are not effective: this
sample query shows which restrictions had fewer than 100 rejections in the
last log file parsed, and the percentage of total rejections each of those
restrictions represents.

\begin{verbatim}
SELECT name, description, restriction_name, hits,
        (hits * 100.0 /
            (SELECT SUM(hits)
                FROM rules
                WHERE postfix_action = 'REJECTED'
            )
        ) || '%' AS percentage
    FROM rules
    WHERE postfix_action = 'REJECTED'
        AND hits < 100
    ORDER BY hits ASC;
\end{verbatim}

The database queries above yield summary statistics about the efficiency of
anti-spam techniques.  These statistics are far less feasible to assess
directly from log files without prior pre-processing into a database in the
fashion proposed, implemented, and tested herein.

\subsection{Database as Application Programming Interface}

\label{database as API}

The database populated by this program provides a simple interface to
Postfix log files.  Although the interface is a database schema rather than
a set of functions provided by shared code, it is in effect quite similar
to any other \gls{API}: it provides a stable interface for users of the
interface, allowing the implementation to be changed without adverse
effects.  As long as the \gls{API} is maintained, the parser can be
improved to handle additional complications; support can be added for
earlier or later releases of Postfix; bugs can be fixed or limitations
removed.

Using a database simplifies writing programs that need to interact with the
data in several ways:

\begin{enumerate}

    \item Facilities are provided to access databases from most programming
        languages, allowing a developer to access the data gathered using
        their preferred programming language, rather than being restricted
        to the language the parser is written in.  It is often possible to
        write an interface layer allowing code written in one language to
        be used in another language, but this greatly increases the effort
        required to use the parser.

    \item Databases provide complex querying and sorting functionality to
        the user without requiring large amounts of programming.  All
        databases provide a program, of varying complexity and
        sophistication, that can be used for ad hoc queries with minimal
        investment of time.

    \item Databases are easily extensible, e.g.:

        \begin{itemize}

            \item New columns can be added to the tables used by the
                program, with sufficient DEFAULT clauses or a clever
                TRIGGER or two.\footnote{Please refer to an \gls{SQL} guide
                for explanations of these terms, e.g.\
                \url{http://philip.greenspun.com/sql/}.}

            \item A VIEW gives a custom arrangement of data with very
                little effort.

            \item If the database supports it, access can be granted on a
                fine-grained basis, e.g.\ allowing the finance department
                to produce invoices, the helpdesk to run limited queries as
                part of dealing with support calls, and the administrators
                to have full access to the data.

            \item Triggers can be written to perform actions when certain
                events occur.  In pseudo-\gls{SQL}\@:

\begin{verbatim}
CREATE TRIGGER ON INSERT INTO results
    WHERE sender = 'boss@example.com'
        AND postfix_action = 'REJECTED'
    SEND PANIC EMAIL TO 'postmaster@example.com';
\end{verbatim}

            \item Other tables can be added to the database, e.g.\ to cache
                historical, summary or computed data.

        \end{itemize}


    \item \gls{SQL} is reasonably standard and many people will already be
        familiar with it; for those unfamiliar with it there are lots of
        readily available resources from which to learn (a good
        introduction to \gls{SQL} can be found at
        \url{http://philip.greenspun.com/sql/}, others are
        \url{http://www.w3schools.com/sql/default.asp},
        \url{http://sqlcourse.com/}).  Although every vendor implements a
        different dialect of \gls{SQL}, the basics are the same everywhere
        (analogous to the overall similarities and minor differences
        between Irish English, British English, American English, and
        Australian English).  Depending on the database in use there may be
        tools available that reduce or remove the requirement to know
        \gls{SQL}; several are available for \gls{SQLite}
        (\url{http://www.sqlite.org/}), the default database used by the
        parser implementation.

\end{enumerate}

Storing the results in a database will also increase the efficiency of
using those results, because the log files need only be parsed once rather
than each time the data is used; indeed the results may be used by someone
with no access to the original log files.



\subsection{Simple Mail Transfer Protocol}

\label{SMTP background}

The \acrlong{SMTP}, originally defined in \gls{RFC}~821~\cite{RFC821} and
updated in \gls{RFC}~2821~\cite{RFC2821}, is used for transferring mail
between the sending and receiving \gls{MTA}\@.  It is a simple, human
readable, plain text protocol, making it quite easy to test and debug
problems with it.  Despite the simplicity of the protocol many virus and
spam sending programs fail to implement it properly, so requiring strict
adherence to the protocol specification is beneficial in protecting against
spam and viruses.\footnote{\label{footnote:rfc760}Originally all mail
servers adhered to the principle of \textit{Be liberal in what you accept,
and conservative in what you send\/} from \gls{RFC}~760~\cite{rfc760}, but
unfortunately that principle was written in a friendlier time.  Given the
deluge of spam that mail servers are subjected to daily, a more appropriate
maxim could be: \textit{Require strict adherence to \gls{RFC}~2821;
implement the strongest restrictions you can; relax the restrictions and
adherence only when legitimate mail is impeded.\/}  it is not as friendly,
nor as catchy, but it more accurately reflects the current situation.} A
typical \gls{SMTP} conversation resembles the following (the lines starting
with a three digit number are sent by the server, all other lines are sent
by the client):

\begin{verbatim}
220 smtp.example.com ESMTP
HELO client.example.com
250 smtp.example.com
MAIL FROM: <alice@example.com>
250 2.1.0 Ok
RCPT TO: <bob@example.com>
250 2.1.5 Ok
DATA
354 End data with <CR><LF>.<CR><LF>
Message headers and body sent here.
.
250 2.0.0 Ok: queued as D7AFA38BA
QUIT
221 2.0.0 Bye
\end{verbatim}

An example deviation from the protocol:

\begin{verbatim}
220 smtp.example.com ESMTP
HELO client.example.com
250 smtp.example.com
MAIL FROM: Alice N. Other alice@example.com
501 5.1.7 Bad sender address syntax
RCPT TO: Bob in Sales/Marketing bob@example.com
503 5.5.1 Error: need MAIL command
DATA
503 5.5.1 Error: need RCPT command
Message headers and body sent here.
.
502 5.5.2 Error: command not recognized
QUIT
221 2.0.0 Bye
\end{verbatim}

This example client is so poorly written that not only does it present the
sender and recipient addresses improperly, it ignores the error messages
returned by the server and carries on regardless.  Many spam and virus
sending programs are this deficient --- unfortunately others (particularly
newer programs) were written by competent programmers, or utilise
competently written programs (e.g.\ Postfix or Sendmail on Unix hosts,
Microsoft Outlook on Windows hosts).  Traditionally a mail server would
have done its best to deal with deficient clients, with the intention of
accepting as much mail destined for its users as
possible,\footref{footnote:rfc760} e.g.\ by ignoring the absence of a HELO
command, or by accepting sender or recipient addresses that were not
enclosed in \texttt{<>}.  

A detailed description of \gls{SMTP} is beyond the scope of this thesis:
introductory guides can be found at~\cite{smtp-intro-01,smtp-intro-02},
and the definitive references are~\cite{RFC821,RFC2821}.

\subsection{Postfix}

\label{postfix background}

Postfix is a \acrlong{MTA}~(\gls{MTA}) with the following design aims (in
order of importance): security, flexibility of configuration, scalability,
and high performance.  It features extensive optional anti-spam
restrictions, allowing an administrator to deploy those restrictions which
they judge suitable for their site's needs, rather than a fixed set chosen
by Postfix's author.  These restrictions can be selectively applied,
combined, and bypassed on a per-client, per-recipient, or per-sender basis,
allowing varying levels of stricture and permissiveness.  Postfix leverages
simple lookup tables to support arbitrarily complicated user-defined
sequences of restrictions and exceptions; policy servers
(\sectionref{policy servers}) provide a simple way to write new
restrictions.  Administrators can also supply their own rejection messages
to make it clear to senders exactly why their mail was rejected.
Unfortunately this flexibility has a cost: complexity in the log files
generated.  Although it is easy to use standard Unix text processing
utilities to determine the fate of an individual email, following the
journey an email takes through Postfix can be quite difficult.  For most
mails the journey is simple and brief, but the remaining minority can have
quite complex journeys (see \sectionref{complications} for details).

Postfix's design follows the Unix philosophy of \textit{``Write programs
that do one thing and do it well''\/}~\cite{unix-philosophy}, and is
separated into various component programs to perform the tasks required of
an \gls{MTA}\@: receive mail, send mail, local delivery of mail, etc.\ ---
full details can be found in~\cite{postfix-overview}.  Each log line
contains the name of the Postfix component that produced it, and this
information is used when determining which rules should be used to parse
each log line (see \sectionref{rule characteristics} for details).
Postfix's design is strongly influenced by security concerns: those
components that interact with other hosts are not
privileged,\footnote{Privilege means the power to perform actions that are
limited to the administrator, and not available to ordinary users.} so bugs
in those components will not give an attacker extra privileges; those
components that are privileged do not interact with other hosts, making it
much more difficult for an attacker to exploit any bugs that may exist in
those components.

\subsubsection{Mixing and matching Postfix restrictions}

\label{Mixing and matching Postfix restrictions}

Postfix restrictions are documented fully in~\cite{smtpd_access_readme,
smtpd_per_user_control, policy-servers}; the following is a brief overview
only.

Postfix uses one restriction list (containing zero or more restrictions)
for each stage of the \gls{SMTP} conversation: client connection, HELO
command, MAIL FROM command, RCPT TO commands, DATA command, and end of
data.  The appropriate restriction list is evaluated for each stage
(evaluation will be explained shortly), though by default the restriction
lists for client connection, HELO, and MAIL FROM commands will not be
evaluated until the first RCPT TO command is received, because some clients
do not deal properly with rejections before the first RCPT TO command; a
benefit of this delay is that Postfix has more information available when
logging rejections.

Each restriction is evaluated to produce a result of \textit{reject},
\textit{permit}, \textit{dunno\/} or the name of another restriction to be
evaluated.\footnote{Other results are possible as described
in~\cite{smtpd_access_readme,smtpd_per_user_control,policy-servers}.} The
meaning of \textit{permit\/} and \textit{reject\/} is fairly obvious;
\textit{dunno\/} means to stop evaluating the current restriction and
continue processing the remainder of the restriction list, allowing
exceptions to more general rules.  When the result is the name of another
restriction Postfix will evaluate that restriction, allowing restrictions
to be chosen based on the client \gls{IP} address, client hostname, HELO
hostname, sender address, or recipient address.\footnote{E.g.\ the
administrator may require that all clients on the local network have valid
DNS entries, to prevent people sending mail from unknown machines.}  The
administrator can define new restrictions as a list of existing
restrictions, allowing arbitrarily long and complex sequences of lookups,
restrictions and exceptions.  Postfix tries to protect the administrator in
as far as is reasonable, e.g.\ the restriction
\texttt{check\_helo\_mx\_access} cannot cause a mail to be accepted,
because the parameter it checks (the hostname given in the HELO command) is
under the control of the remote client.  Despite this, it is possible for
the administrator to make catastrophic mistakes, e.g.\ rejecting all mail
--- the administrator must be cognisant of the effects their configuration
changes will have.  This is similar to one of UNIX's design philosophies:
\textit{``UNIX was not designed to stop its users from doing stupid things,
as that would also stop them from doing clever
things''\/}~\cite{unix-philosophy}.

Postfix uses simple lookup tables to make decisions when evaluating some
restrictions, e.g.\newline{}
\tab{}\texttt{check\_client\_access~cidr:/etc/postfix/client\_access}

\begin{eqlist}

    \item [check\_client\_access] The name of the restriction to evaluate.

    \item [cidr] The type of the lookup table.

    \item [/etc/postfix/client\_access] The file containing the lookup
        table.

\end{eqlist}

The restriction \texttt{check\_client\_access} checks if the \gls{IP}
address of the connected client is found in the specified table and returns
the associated action if found; the method of searching the file is
dependant on the type of the file (\texttt{cidr} in the example) --- see
\cite{postfix-lookup-tables} for more details.  Other restrictions
determine their result by consulting external sources, e.g.\newline{}
\tab{}\texttt{reject\_rbl\_client dnsbl.example.com}\newline{} checks the
\gls{DNSBL} \texttt{dnsbl.example.com} and rejects the command if the
client's \gls{IP} address is listed.

For further information about Postfix restrictions
see~\cite{smtpd_access_readme,smtpd_per_user_control,policy-servers}.

\subsubsection{Policy servers}

\label{policy servers}

A policy server~\cite{policy-servers} is an external program consulted by
Postfix to determine the fate of an \gls{SMTP} command.  The policy server
is given state information by Postfix (sample state information is shown in
\tableref{Example attributes sent to policy servers}) and returns a verdict
from the set described in \sectionref{Mixing and matching Postfix
restrictions}.  The policy server can perform more complex checks than
those provided by Postfix: a trivial example is allowing addresses
associated with the payroll system to send mail on the third Tuesday after
pay day only, to help prevent problems from phishing mails using faked
sender addresses.\footnote{A phishing mail might claim that the payroll
system had a disastrous disk failure, and until the server is replaced all
salary payments will have to be processed manually, so please reply to this
mail with your name, address, and bank account details.}

\begin{table}[ht]

    \caption{Example attributes sent to policy servers}
    \empty{}\label{Example attributes sent to policy servers}

    \centering{}

    \begin{tabular}[]{ll}

        request                 & smtpd\_access\_policy     \\
        protocol\_state         & RCPT                      \\
        protocol\_name          & SMTP                      \\
        helo\_name              & some.domain.tld           \\
        queue\_id               & 8045F2AB23                \\
        sender                  & foo@bar.tld               \\
        recipient               & bar@foo.tld               \\
        recipient\_count        & 0                         \\
        client\_address         & 1.2.3.4                   \\
        client\_name            & another.domain.tld        \\
        reverse\_client\_name   & another.domain.tld        \\
        instance                & 123.456.7                 \\

    \end{tabular}

\end{table}

Some widely deployed policy servers:

\begin{itemize}

    \item Sender Policy Framework (SPF)~\cite{openspf}.  SPF\label{spf
        introduction} records specify which mail servers are allowed to
        send mail claiming to be from a particular domain.  The intention
        is to reduce spam from faked sender addresses,
        backscatter~\cite{postfix-backscatter}, and
        joe~jobs~\cite{Wikipedia-joe-job}\glsadd{Joe job}.  There has been
        considerable resistance to the proposal because it breaks or vastly
        complicates some features of \gls{SMTP}, e.g.\ forwarding mail from
        one company or university to another when a user moves.

    \item Greylisting~\cite{greylisting} is a technique that temporarily
        rejects a delivery attempt when the triple of \newline{}
        \tab{}\texttt{(sender address, recipient address, remote \gls{IP}
        address)}\newline{} has not been seen before; on second and
        subsequent delivery attempts from that triple the mail will be
        accepted.  This blocks spam because maintaining a list of failed
        addresses and retrying after a temporary failure is uneconomical
        for a spam sender, but a legitimate mail server must retry
        deliveries that temporarily failed.  Sadly spam senders are using
        increasingly complex and well written programs to distribute spam,
        frequently using an ISP provided \gls{SMTP} server from a
        compromised machine on the ISP's network.  Greylisting will slowly
        become less useful, but it does block a large percentage of spam
        mail at the moment; the most effective restrictions from the
        \numberOFlogFILES{} log files used in testing the parser are shown
        in \tableref{Summary of rejections}.  Greylisting is obviously
        worth using, at least at the moment, particularly when you consider
        Greylisting's position as the final restriction that a mail must
        overcome:\footnote{Greylisting is the final restriction a mail must
        overcome in the configuration used on the mail server the log files
        were obtained from; an administrator is free to use Greylisting
        wherever in the restriction list they feel is most appropriate for
        their mail system.} Greylisting only takes effect for mails that
        have passed every other restriction.  Some problems may be
        encountered when using greylisting: some servers fail to retry;
        legitimate mail may be delayed, particularly when coming from a
        pool of servers.

        \begin{table}[ht]
            \caption{Summary of rejections}\label{Summary of rejections}
            \input{build/include-restriction-summary-table}
        \end{table}

    \item Scoring systems such as Policyd-weight~\cite{policyd-weight}
        perform tests on features of the delivery attempt (e.g.\ \gls{IP}
        address, sender address), incrementing or decrementing a score
        based on the results; if the eventual score is higher than a
        threshold the mail is rejected.  The administrator must manually
        whitelist clients if they are to bypass a Postfix restriction;
        using a threshold that requires a delivery attempt to hit several
        restrictions frees the administrator from whitelisting clients that
        fall foul of one restriction only.

    \item Rate limiting on a per-sender, per-client or per-recipient basis
        as performed by Policyd~\cite{policyd}.

\end{itemize}



\subsection{Summary}

This section has provided background information on several topics,
starting with the motivation behind the project, continuing with an
explanation of the use of a database as an \gls{API} and an introduction to
\gls{SMTP}.  The focus then switched to Postfix, the \gls{MTA} in use, and
its restrictions and policy servers.
