/* vim: set textwidth=160 : */
/* $Id$ */

digraph logparser {
    graph [
        /* This seems to be width, height - but they interact strangely, so 
         * I'm never sure.
         */
        size = "6.0, 6.4"
        margin = "0"
        center = true
    ]
    node [
        shape = box
    ]
    edge [
        color = blue
        fontcolor = red
        minlen = 2
    ]

    /* EDGES */
    /* Connect from client */
    connect                         -> { rejection } [weight = 5]
    rejection                       -> { rejection } [dir = back, headport = s, tailport = nw]
    rejection                       -> { disconnect } [weight = 5]
    connect                         -> { clone }
    clone                           -> { clone } [dir = back, headport = s, tailport = ne]
    clone                           -> { disconnect }
    clone                           -> { rejection }
    rejection                       -> { clone }

    /* Disconnect without queueid */
    disconnect                      -> { if_no_queueid }
    if_no_queueid                   -> { fixup_enter_in_db_disconnect }
    fixup_enter_in_db_disconnect    -> { delete_by_pid_disconnect }

    /* Disconnect with queueid */
    if_no_queueid                   -> { save_by_queueid } [weight = 5]

    /* Misc entry */
    pickup                          -> { save_by_queueid } [headport = n]
    qmgr_chooses_mail               -> { save_by_queueid } [headport = ne]
    /* Graph placement */
    connect                         -> { pickup } [style = invis, weight = 0]
    connect                         -> { qmgr_chooses_mail } [style = invis, weight = 0]

    /* Save results by queueid */
    save_by_queueid                 -> { track } [minlen = 5]
    track                           -> { save_by_queueid }
    save_by_queueid                 -> { save_by_queueid } [dir = back, headport = s, tailport = nw]
    save_by_queueid                 -> { commit } [weight = 10]

    /* Expired mails */
    save_by_queueid                 -> { expiry }
    expiry                          -> { commit } [weight = 0]

    /* Commit is complicated */
    /* Neither parent nor child. */
    commit                          -> { if_neither_parent_nor_child }
    if_neither_parent_nor_child     -> { fixup_enter_in_db_npc }
    fixup_enter_in_db_npc           -> { delete_npc }
    /* Untracked child */
    if_neither_parent_nor_child     -> { if_untracked_child }
    if_untracked_child              -> { mark_for_commit }
    mark_for_commit                 -> { wait_for_parent_to_commit_me }
    if_untracked_child              -> { if_tracked_child }
    /* Tracked child */
    if_tracked_child                -> { fixup_enter_in_db_tc }
    fixup_enter_in_db_tc            -> { delete_tc }
    delete_tc                       -> { maybe_delete_parent }
    /* Parent */
    if_tracked_child                -> { parent }
    parent                          -> { fixup_enter_in_db_parent }
    fixup_enter_in_db_parent        -> { commit_children }
    /* This next edge pulls wait_for_children_to_be_deleted leftwards */
    fixup_enter_in_db_parent        -> { wait_for_children_to_be_deleted } [style = invis]
    commit_children                 -> { wait_for_children_to_be_deleted } [headport = nw, tailport = se, weight = 0]
    wait_for_children_to_be_deleted -> { delete_parent }

    /* NODE LABELS */
    rejection                       [label = "4: Postfix rejects SMTP command"]
    connect                         [label = "1: Connection from remote host"]
    clone                           [label = "5: Clone when multiple mails\n(not recipients) are delivered\nduring one connection"]

    /* Disconnect without queueid */
    disconnect                      [label = "6: Disconnection or timeout by client"]
    if_no_queueid                   [label = "7: If no queueid:", shape = diamond]
    fixup_enter_in_db_disconnect    [label = "8: Fixup, enter in db"]
    delete_by_pid_disconnect        [label = "9: Delete from state tables by pid"]

    /* Disconnect with queueid - already covered */

    /* Misc entry */
    pickup                          [label = "2: Mail submitted\nvia sendmail"]
    qmgr_chooses_mail               [label = "3: Mail picked \nfor delivery\nby qmgr"]

    /* Save results by queueid */
    save_by_queueid                 [label = "10: Save by queueid"]
    track                           [label = "11: Track child of this mail\n(usually due to aliases)"]

    /* Expiry */
    expiry                          [label = "12: Mark mail as expired"]

    /* Commit is complicated */
    /* Neither parent nor child. */
    commit                          [label = "13: Mail has been delivered, bounced or deleted"]
    if_neither_parent_nor_child     [label = "14: If not a tracked mail:", shape = diamond]
    fixup_enter_in_db_npc           [label = "15: Fixup, enter in db"]
    delete_npc                      [label = "16: Delete from state tables by queueid"]

    /* Untracked child */
    if_untracked_child              [label = "17: If a child mail waiting\nto be tracked:", shape = diamond]
    mark_for_commit                 [label = "18: Mark for later entry in db"]
    wait_for_parent_to_commit_me    [label = "19: Wait for parent to track and enter in db"]

    /* Tracked child */
    if_tracked_child                [label = "20: If tracked child:", shape = diamond]
    fixup_enter_in_db_tc            [label = "21: Fixup, enter in db"]
    delete_tc                       [label = "22: Delete from state tables by queueid"]
    maybe_delete_parent             [label = "23: Inform parent child\lhas finished"]

    /* Parent */
    parent                          [label = "24: Parent"]
    fixup_enter_in_db_parent        [label = "25: Fixup, enter in db"]
    commit_children                 [label = "26: for each child waiting for parent:\l          fixup and enter child in db\l          delete child by queueid\l", labeljust = l]
    wait_for_children_to_be_deleted [label = "27: Wait for any remaining \nchildren to be deleted"]
    delete_parent                   [label = "28: Delete from state tables by queueid"]

    /* SUB-GRAPHS */
    subgraph sources {
        rank = source
        pickup
        qmgr_chooses_mail
        connect
    }
    subgraph clone_or_save {
        rank = same
        clone
        rejection
    }
    subgraph disconnect_without_queueid {
        rank = same
        if_no_queueid
        fixup_enter_in_db_disconnect
        delete_by_pid_disconnect
    }
    subgraph save_or_track {
        rank = same
        track
        save_by_queueid
        expiry
    }
    subgraph not_tracked {
        rank = same
        if_neither_parent_nor_child
        fixup_enter_in_db_npc
        delete_npc
    }
    subgraph untracked_child {
        rank = same
        if_untracked_child
        mark_for_commit
        wait_for_parent_to_commit_me
    }
    subgraph tracked_child {
        rank = same
        if_tracked_child
        fixup_enter_in_db_tc
        delete_tc
        maybe_delete_parent
    }
    subgraph parent {
        rank = same
        parent
        fixup_enter_in_db_parent
        commit_children
    }
    subgraph parent_waiting {
        rank = same
        wait_for_children_to_be_deleted
        delete_parent
    }
}
