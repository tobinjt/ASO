\documentclass{beamer}
%\mode<presentation>
%{
%  \usetheme{Warsaw}
%  % or ...
%
%  \setbeamercovered{transparent}
%  % or whatever (possibly just delete it)
%}
\useoutertheme{infolines}
\defbeamertemplate*{headline}{JT theme}{}

\usepackage[english]{babel}
% or whatever

\usepackage[latin1]{inputenc}
% or whatever

\usepackage{times}
\usepackage[T1]{fontenc}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.

\newcommand{\timingnote}[1]{%
    \textbf{#1}%
}

\title{A User-Extensible and Adaptable Parser Architecture}

\author[John Tobin \and Carl Vogel]{John Tobin \and Carl Vogel\\
    tobinjt@cs.tcd.ie vogel@cs.tcd.ie}
% - Give the names in the same order as the appear in the paper.
% - Use the \inst{?} command only if the authors have different
%   affiliation.

\institute[Trinity College]
{
    School of Computer Science and Statistics,\\
    Trinity College, University of Dublin
}

\date[SGAI 2008]{Twenty-eighth SGAI International Conference on Artificial Intelligence}

\subject{Theoretical Computer Science}

% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[height=0.5cm]{university-logo}{university-logo-filename}
% \logo{\pgfuseimage{university-logo}}


\begin{document}

\begin{frame}
    \timingnote{30 seconds}
    \titlepage{}
\end{frame}

\begin{frame}{Outline Of This Talk}
    \timingnote{30 seconds --- 1 minute}
    \tableofcontents{}
\end{frame}


% Structuring a talk is a difficult task and the following structure
% may not be suitable. Here are some rules that apply for this
% solution: 

% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

% - A conference audience is likely to know very little of what you
%   are going to talk about. So *simplify*!
% - In a 20min talk, getting the main ideas across is hard
%   enough. Leave out details, even if it means being less precise than
%   you think necessary.
% - If you omit details that are vital to the proof/implementation,
%   just say so once. Everybody will be happy with that.

\section{Background}

\begin{frame}{Background}

    \timingnote{1--2 minutes}

    This parser architecture was developed as part of a larger project to
    improve anti-spam techniques.

    \begin{description}

        \item [Currently] Most of the commonly used anti-spam techniques
            are content-based, and require each mail to be accepted before
            determining its spam status.

        \item [However] Rejecting mail at SMTP-time is more efficient, and
            senders of non-spam mails that are incorrectly rejected will
            receive a bounce notification immediately.

        \item [Project Aim] To improve SMTP-time anti-spam techniques, by
            providing a platform for reasoning about anti-spam techniques.

        \item [Method] Parse Postfix log files and analyse the
            extracted data.

        \item [Therefore] This method requires a parser for Postfix log
            files.

    \end{description}

\end{frame}

\section{Characteristics Of The Input: Postfix Log Files}

\begin{frame}{Characteristics Of The Input: Postfix Log Files}

    \timingnote{1 minute}

    \begin{itemize}

        \item Postfix log lines change over time and from site to site, so
            it must be easy for the end user to parse new log lines.

        \item The processing required for a type of log line (e.g.\
            rejecting a mail delivery attempt) rarely changes, but it can
            be quite complex.

        \item By separating parsing of log lines from processing of log
            lines, we can make parsing new or changed log lines as easy as
            possible, while still allowing for complicated processing when
            necessary.

    \end{itemize}

\end{frame}


\section{Parser Architecture}

\begin{frame}{Parser Architecture}

    \timingnote{2 minutes}

    The parser architecture is divided into three parts: Framework,
    Actions, and Rules.

    \begin{description}

        \item [Framework] The framework manages rules and provides support
            functions to actions, e.g.\ data storage, inter-action
            communication, and utility functions.  For each input log line,
            the framework tries each rule in turn until one matches, then
            it invokes the action specified by the rule.

        \item [Actions] Each action performs the processing required by one
            type of log line.  Actions correspond to events: events within
            Postfix create log lines, and actions perform the processing
            required by those events.

        \item [Rules] Each rule matches one log line variant, e.g.\ the log
            line resulting from client connecting, a mail successfully
            delivered, or a mail rejected by an anti-spam measure.

    \end{description}

\end{frame}

\section{Features Of The Architecture}

\begin{frame}{Features Of The Architecture}

    \timingnote{2 minutes}

    \begin{itemize}

        \item The architecture can be used when parsing input files that
            are not completely understood or that do not have 100\% parsing
            coverage.  \timingnote{Emphasise this.}

        \item Rules can be tagged with conditions which must hold before
            the rule will be used when attempting to match an input.

        \item The parser does not need to be recompiled when rules are
            changed, allowing: quicker testing of modified rules; easing
            interchange of rulesets; combining two or more rulesets.

        \item Cascaded Parsing.

        \item Rules can be added, changed, or removed by actions while the
            parser is running, allowing dynamically changing parsing, e.g.\
            macros.  This feature must be used with care.
            \timingnote{Currying functions in a calculator might be a good
            example.}

    \end{itemize}

\end{frame}


\section{Results Of Writing A Parser Using This Architecture}

\begin{frame}{Results Of Writing A Parser Using This Architecture}

    \timingnote{1--2 minutes}

    \begin{itemize}

        \item 100\% coverage of log lines.

        \item 100\% coverage of all mails accepted, delivered, or rejected.

        \item Zero false positives or false negatives.

        \item 169 rules parsing 522 contiguous log files: the top 10 rules
            match 85.03\% of the log lines, the remainder tail off similar
            to a Power Law distribution.

        \item 18 actions; most are triggered by only one or two rules.
            \timingnote{client connecting, postfix reloading}

        \item The top three actions are triggered by 41, 49, and 59 rules.
            \timingnote{build/stats-action-distribution:}
            \timingnote{uninteresting, save\_data, delivery\_rejected}

    \end{itemize}

\end{frame}

\section{Parser Efficiency}

\begin{frame}{Parser Efficiency}

    \timingnote{2 minutes}

    \begin{itemize}

        \item Median throughput is 80.85~MB (480,569 log lines) parsed per
            minute; median log file size is 50 MB, containing 285,000 log
            lines.

        \item Rules are tagged with the name of a Postfix component, and
            will only be used to parse log lines produced by that
            component.

        \item Rules are sorted by how frequently they match, resulting in a
            mean reduction of 14.78\% in parsing time compared to using
            unsorted rules.  Priority attribute can be used to override
            this.

        \item The architecture scales extremely well as the number of rules
            increases: a 46.05\% increase in the Postfix ruleset ($115
            \rightarrow{} 169$ rules) resulted in a mean increase of 0.63\%
            in parsing time.

        \item Parsing time scales linearly with input size, but
            \textit{is\/} affected by input content: the content determines
            the actions that will run, and some actions take longer to run
            than others.

    \end{itemize}

\end{frame}

\section{Future Directions}

\begin{frame}{Future Directions}

    \timingnote{1--2 minutes}

    \begin{itemize}

        \item Data mining to determine how well each anti-spam technique
            works.

        \item Data mining to search for combinations of features which can
            be used to detect spam, and development of new anti-spam
            techniques to defeat such spam.

        \item Use Machine Learning techniques instead of writing rules;
            Instance Based Learning techniques must be used due to the size
            of the data set.  \timingnote{Compare to SLCT-based tool.}

        \item Detection of overlapping rules: intersection of Finite
            Automata or Push-Down Automata.

        \item Provide a reference implementation.

    \end{itemize}

\end{frame}


\section{Summary}

\begin{frame}{Summary}

    \timingnote{1 minute}

    \begin{itemize}

        \item Parser Architecture makes it easy to develop a flexible yet
            strict parser.

        \item Parser Architecture makes it easy for users to parse new or
            changed inputs.

        \item Parser can still be efficient and fast.

    \end{itemize}

    \timingnote{remainder}

    \begin{itemize}

        \item Questions?

        \item Comments?

    \end{itemize}

\end{frame}

\end{document}
