#!/usr/bin/env perl

# $Id$

use strict;
use warnings;

use lib qw(..);
use ASO::Parser;
use File::Temp;
use File::Spec;
use IO::File;
use Data::Dumper;
$Data::Dumper::Sortkeys = 1;
use List::Util qw(sum);
use File::Slurp;

my ($regexs_file) = shift @ARGV;

# Compile all the regexs.
my @bare_regexs = read_file($regexs_file);
chomp @bare_regexs;
my @regexs;
foreach my $bare_regex (@bare_regexs) {
    $bare_regex =~ m/^(\d+)\s+(.*)$/;
    my %regex = (
        expected    => $1,
        orig_regex  => $2,
    );
    my $filtered_regex = ASO::Parser::filter_regex(undef, $regex{orig_regex});
    $regex{compiled_regex} = qr/$filtered_regex/;
    push @regexs, \%regex;
}

#warn Dumper(\@regexs);
LINE:
while (<>) {
    my @match;
    foreach my $regex (@regexs) {
        if (m/$regex->{compiled_regex}/) {
            $regex->{matches}++;
            push @match, $regex;
            #next LINE;
        }
    }
    if (@match > 1) {
        warn qq{Multiple match: }, $_, Dumper(\@match);
    }
}

foreach my $regex (@regexs) {
    warn qq{expected: $regex->{expected}; matches: $regex->{matches}; }
        . qq{regex: $regex->{orig_regex}\n};
    if ($regex->{matches} < $regex->{expected}) {
        my $difference = $regex->{expected} - $regex->{matches};
        warn qq{!!!! $regex->{matches} < $regex->{expected}; $difference less\n};
    }
}
