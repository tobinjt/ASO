#!/usr/bin/env perl

# $Id$

use strict;
use warnings;
$| = 1;

use lib q{..};
use ASO::DB;
use ASO::Parser;
use Carp;
use Getopt::Long;
use Pod::Usage;
use File::Temp qw(tempfile);

binmode STDOUT;
binmode STDERR;

my ($Options, $parser_options) = get_options();

# Ensure that we don't try to read from a terminal.
my @logs = @ARGV;
if (not @logs and -t STDIN) {
    die qq{Usage: $0 logfile [logfiles]\n};
}
if (not @logs) {
    @logs = q{-};
}

# Save the startup times seperately, when profiling with Devel::Profile.
devel_profile_startup();
set_SmallProf_packages();

warn qq{vim: set foldmethod=marker :\n};
my $parser = ASO::Parser->new($parser_options);
if ($Options->{q{in-statefile}}) {
    $parser->load_state($Options->{q{in-statefile}});
}

foreach my $logfile (@logs) {
    timewarn(qq{Starting to read $logfile\n});
    $parser->parse($logfile);
    my $statefile = IO::File->new(q{>} . $Options->{q{out-statefile}})
        or die qq{Failed to open $Options->{q{out-statefile}}: $!\n};
    print $statefile $parser->dump_state();
}

timewarn(qq{Updating rule_order\n});
$parser->update_check_order();

# Some profiling modules dump their data to stdout, but we want to redirect
# that.  If the correct environment variable is set stdout will be redirected
# here and the data will go to the requested file.
redirect_stdout();

sub devel_profile_startup {
    if (exists $ENV{PERL_PROFILE_SAVETIME}) {
        DB::reset();
        my $filename;
        if (exists $ENV{PERL_PROFILE_FILENAME}) {
            $filename = $ENV{PERL_PROFILE_FILENAME};
        } else {
            $filename = q{prof.out};
        }
        rename $filename, qq{$filename.startup}
            or warn qq{$0: failed renaming $filename: $!\n};
    }
}

sub set_SmallProf_packages {
    if (exists $INC{q{Devel/SmallProf.pm}}) {
        # Silence warnings about it on;y being used once.
        %DB::packages = ();
        %DB::packages = (
            q{main}                 => 1,
            q{ASO::DB}              => 1,
            q{ASO::DB::Connection}  => 1,
            q{ASO::DB::Result}      => 1,
            q{ASO::DB::Rule}        => 1,
            q{ASO::Parser}          => 1,
        );
    }
}

sub redirect_stdout {
    if (exists $ENV{REDIRECT_STDOUT}) {
        close STDOUT;
        open STDOUT, qq{> $ENV{REDIRECT_STDOUT}};
    }
}

sub get_options {
    my %parser_options = (
        q{data_source=s}            => q{dbi:SQLite:dbname=../sql/db.sq3},
        q{sort_rules=s}             => q{normal},
        q{discard_compiled_regex}   => 0,
        q{skip_inserting_results}   => 1,
    );
    my %opts = (
        q{in-statefile|i=s}         => undef,
        q{out-statefile|o=s}        => q{state},
        q{help|h}                   => 0,
        q{version|v}                => 0,
        %parser_options,
    );

    my @switches    = keys %opts;
    %opts           = getopt_to_key(%opts);
    %parser_options = getopt_to_key(%parser_options);

    Getopt::Long::Configure qw(no_getopt_compat permute bundling);
    Getopt::Long::GetOptions(\%opts, @switches) or pod2usage(2);

    if ($opts{help}) {
        pod2usage(
            -verbose    => 1,
            -exitval    => 0,
        );
    }
    if ($opts{version}) {
        my $version = q{$Id$};
        print qq{$0 version $version\n};
        exit 0;
    }

    map { $parser_options{$_} = $opts{$_}; } keys %parser_options;

    return (\%opts, \%parser_options);
}

# Convert keys from Getopt::Long option specifiers to option names.
sub getopt_to_key {
    my (%opts) = @_;
    my %names;

    map {
        my ($key, $value) = ($_, $opts{$_});
        $key =~ s/\|.*//;
        $key =~ s/=.*//;
        $names{$key} = $value;
    } keys %opts;

    %names;
}

sub timewarn {
    warn qq{$0: }, scalar localtime, q{: }, @_;
}
