#!/usr/bin/env perl

# $Id$

# NOTES: for successful mail, I get:
#   postfix/smtpd: 6F3D44317: client=webbie.berkeley.intel-research.net[12.155.161.150]
#   postfix/qmgr: 6F3D44317: from=<dtn-interest-admin@mailman.dtnrg.org>, size=11880, nrcpt=2 (queue active)
#   postfix/smtp: 6F3D44317: to=<elizabeth.daly@cs.tcd.ie>, relay=127.0.0.1[127.0.0.1], delay=14, status=sent (250 2.6.0 Ok, id=18003-11, from MTA([127.0.0.1]:11025): 250 Ok: queued as B370843FD)
#   postfix/smtp: 6F3D44317: to=<stephen.farrell@cs.tcd.ie>, relay=127.0.0.1[127.0.0.1], delay=14, status=sent (250 2.6.0 Ok, id=18003-11, from MTA([127.0.0.1]:11025): 250 Ok: queued as B370843FD)
#   postfix/qmgr: 6F3D44317: removed
# That gives me: hostname, ip, sender, recipients (I can sanity check recipient
# number using nrcpt), smtp code, queueid, timestamps, result.
# So far I don't have HELO.  The queueid ties those lines together.  Can I get
# postfix to log the HELO somehow?  There might be cleanup lines too . . . just
# message-id, I think.

use strict;
use warnings;

use lib q{..};
use ASO::DB;
use Parse::Syslog;
use IO::File;
use Carp;
use Data::Dumper;
use Regexp::Common qw(Email::Address net);

my $dbix = ASO::DB->connect(
    q{dbi:SQLite:dbname=../sql/db.sq3},
    {AutoCommit => 0},
);

my @logs = @ARGV;
if (not @logs and -t STDIN) {
    die qq{Usage: $0 logfile [logfiles]\n};
}
if (not @logs) {
    @logs = q{-};
}

my @rules                   = load_rules();
my %rules_by_program        = map { $_->{program} => [] } @rules;
map { push @{$rules_by_program{$_->{program}}}, $_ } @rules;

# programs which can create connections
my %connect_programs        = (
    q{postfix/smtpd}        => 1,
);
# programs which implement restrictions, and thus need to be processed by 
# restriction_start below.
my %restriction_programs    = (
    q{postfix/smtpd}        => 1,
);
my $restriction_start       = make_restriction_start();

my (%connections, %queueids);
my $num_connections_uncommitted = 0;
my $current_logfile;

foreach my $logfile (@logs) {
    print qq{$0: Starting to read $logfile\n};
    $current_logfile = $logfile;
    my $syslog = Parse::Syslog->new($logfile, year => 2006);
    if (not $syslog) {
        croak qq{Failed creating parser for $logfile: $@\n};
    }

    LINE:
    while (my $line = $syslog->next()) {
        if (not exists $rules_by_program{$line->{program}}) {
            # It's not from a program we're interested in, skip it.
            next LINE;
        }

        # Parse::Syslog handles "last line repeated n times" by returning the 
        # same hash as it did on the last call, so any changes we make to the 
        # contents of the hash will be propogated, thus we need to work on a
        # copy of the text of the line from now on.
        my $text = $line->{text};

        # The start of every restriction line is the same, so strip it off here;
        # however, not every line matches restriction_start.
        if (exists $restriction_programs{$line->{program}}) {
            my @matches = $text =~ m/$restriction_start->{regex}/;
            if (@matches) {
                $text =~ s/$restriction_start->{regex}//;
                save($line, $restriction_start, \@matches);
            }
        }

        RULE:
        foreach my $rule (@{$rules_by_program{$line->{program}}}) {
            if ($text !~ m/$rule->{regex}/) {
                next RULE;
            }
            $rule->{count}++;

            # XXX: is there a way I can do this without matching twice??
            my @matches = ($text =~ m/$rule->{regex}/);
            # regex matches start at one, but array indices start at 0.
            # shift the array forward so they're aligned
            unshift @matches, undef;

            # A line we want to ignore
            if (uc $rule->{action} eq q{IGNORE}) {
                next LINE;
            }

            # Someone has connected to us
            if (uc $rule->{action} eq q{CONNECT}) {
                make_connection($line);
                # We also want to save the hostname/ip info
                save($line, $rule, \@matches);
                next LINE;
            }

            # Someone has disconnected
            if (uc $rule->{action} eq q{DISCONNECT}) {
                disconnection($line, \@matches);
                next LINE;
            }

            # We want to save some information
            if (uc $rule->{action} eq q{SAVE}) {
                save($line, $rule, \@matches);
                next LINE;
            }

            # We want create db entries with the information we've saved.
            if (uc $rule->{action} eq q{COMMIT}) {
                commit($line, $rule, \@matches);
                next LINE;
            }

            # We need to track a mail across queueids, typically when mail
            # goes through amavisd-new.
            if (uc $rule->{action} eq q{TRACK}) {
                save($line, $rule, \@matches);
                track($line, $rule, \@matches);
                next LINE;
            }

            my_warn(qq{unknown action $rule->{action}\n} . Dumper($rule));
        }

        # Last ditch: complain to the user
        print qq{$line->{program}: $text\n};
        #my_warn(qq{unknown line: $line->{program}: $line->{pid}: $text\n});
    }
}
if ($num_connections_uncommitted) {
    $dbix->txn_commit();
}

#print dump_state();
update_check_order();
#print dump_totals();

sub make_restriction_start {

    my $special_rule = {
        id                  => -1,
        name                => q{special rule matching the start of restrictions},
        program             => q{postfix/smtpd},
        queueid             => 0,
        result_cols         => parse_result_cols(q{queueid = 1, hostname = 3, ip = 4}),
        connection_cols     => parse_result_cols(q{result = 2, smtp_code = 5}),
        regex               => filter_regex(
            qr/^([A-Z0-9]{9}|NOQUEUE): (reject(?:_warning)?): (?:RCPT|DATA) from (?>(__HOSTNAME__)\[)(?>(__IP__)\]): (__SMTP_CODE__) /
        )
    };
    $special_rule->{regex}  = qr/$special_rule->{regex}/;

    return $special_rule;
}

# Maybe use Text::Table?
sub dump_totals {
    my (%map, $length);
    $length = 0;

    foreach my $rule (@rules) {
        $map{$rule->{name}} = $rule->{count};
        if (length $rule->{name} > $length) {
            $length = length $rule->{name};
        }
    }

    my $result = q{};
    my @names = sort { $map{$b} <=> $map{$a} } keys %map;
    foreach my $name (@names) {
        $result .= $name . (q{ } x (3 + $length - length $name)) . $map{$name} . qq{\n};
    }

    return $result;
}

sub update_check_order {
    my ($i, %order_map) = (1);

    map { exists $_->{count} or $_->{count} = 0 } @rules;
    my @sorted_rules = sort { $b->{count} <=> $a->{count} } @rules;
    foreach my $rule (@sorted_rules) {
        $order_map{$rule->{id}} = $i++;
    }
    foreach my $rule ($dbix->resultset(q{Rule})->search()) {
        # Sometimes a rule won't have been hit; just use the next value
        # in the sequence.
        $rule->rule_order($order_map{$rule->id()} || $i++);
        $rule->update();
    }
}

sub parse_result_cols {
    my ($spec) = @_;

    my $assignments = {};
    foreach my $assign (split /\s*,\s*/, $spec) {
        if (not length $assign) {
            croak qq{empty assignment found in: $assignments\n};
        }
        if ($assign !~ m/^\s*(\w+)\s*=\s*(\d+)\s*/) {
            croak qq{bad assignment: $assign\n};
        }
        $assignments->{$1} = $2;
    }
    return $assignments;
}

sub get_connection {
    my ($line, $queueid, $rule) = @_;
    my $connection;

    # Is it a program which makes connections?
    # $queueid supercedes $line->{pid}, for when we use TRACK with programs
    # which create connections.
    if (not $queueid and exists $connect_programs{$line->{program}}) {
        $connection = $connections{$line->{pid}};
        if (not $connection) {
            my_warn(qq{get_connection: no connection for pid $line->{pid}\n});
            $connection = make_connection($line);
        }
        if (not $connection) {
            my_die(qq{get_connection: failed to make_connection()\n});
        }
        return $connection;
    }

    # Or is it a program we track by queueid?
    if (not $queueid) {
        my $dump = dump_rule($rule);
        my_warn(qq{get_connection: no queueid for rule $dump\n});
        return {};
    }

    if (not exists $queueids{$queueid}) {
        # Reasons this happen: reinjection due to forwarding, filtering through
        # amavisd??
        $queueids{$queueid} = { faked => 1 };
    }

    return $queueids{$queueid};
}

# TODO: extend this so it checks that tracked connections are committed.
sub delete_connection {
    my ($line, $queueid) = @_;

    my $deleted = 0;

    if (exists $connect_programs{$line->{program}}) {
        if (not exists $connections{$line->{pid}}) {
            my_warn(qq{delete_connection: no connection for pid $line->{pid}\n});
        } else {
            delete $connections{$line->{pid}};
            $deleted++;
        }
    }

    if ($queueid) {
        if (not exists $queueids{$queueid}) {
            my_warn(qq{delete_connection: no connection for queueid $queueid\n});
        } else {
            delete $queueids{$queueid};
            $deleted++;
        }
    }

    if (not $deleted) {
        my_warn(qq{delete_connection: didn't delete anything!\n},
            qq{\tqueueid => $queueid\n},
            qq{\tline    => } . dump_line($line) . qq{\n},
        );
    }
}

sub load_rules {
    my @results;

    foreach my $rule ($dbix->resultset(q{Rule})->search()) {
        my $rule_hash = {
            id               => $rule->id(),
            name             => $rule->name(),
            rule_order       => $rule->rule_order(),
            priority         => $rule->priority(),
            result           => $rule->result(),
            action           => $rule->action(),
            program          => $rule->program(),
            queueid          => $rule->queueid(),
            result_cols      => parse_result_cols($rule->result_cols()),
            connection_cols  => parse_result_cols($rule->connection_cols()),
        };

        # Compile the regex for efficiency, otherwise it'll be recompiled every
        # time it's used.
        my $regex = filter_regex($rule->regex());
        eval {
            $rule_hash->{regex} = qr/$regex/;
        };
        if ($@) {
            croak qq{$0: failed to compile regex $regex: $@\n} .
                dump_rule_from_db($rule);
        }

        push @results, $rule_hash;
    }
    return sort {      $a->{priority}   <=> $b->{priority} 
                    or $a->{rule_order} <=> $b->{rule_order} } @results;
}

sub dump_connection {
    my ($connection) = @_;

    return Data::Dumper->Dump([$connection], [q{connection}]);
}

sub dump_line {
    my ($line) = @_;

    return Data::Dumper->Dump([$line], [q{line}]);
}

sub dump_rule {
    my ($rule) = @_;

    return Data::Dumper->Dump([$rule], [q{rule}]);
}

sub dump_rule_from_db {
    my ($rule) = @_;

    my %columns = $rule->get_columns();
    return Data::Dumper->Dump([\%columns], [q{rule}]);
}

sub dump_state {
    
    return Data::Dumper->Dump(
        [\%connections, \%queueids],
        [qw(connections queueids)]
    );
}

sub filter_regex {
    my ($regex) = @_;

    # I'm deliberately allowing a trailing .
    my $hostname_re = qr/(?:unknown|(?:[-_a-zA-Z0-9.]+))/;

    $regex =~ s/__SENDER__      /__EMAIL__/gx;
    $regex =~ s/__RECIPIENT__   /__EMAIL__/gx;
    # We see some pretty screwey hostnames in HELO commands.
    $regex =~ s/__HELO__        /__HOSTNAME__|(?:\\[)__IP__(?:\\])|(.*?)/gx;
#   This doesn't work, as it matches valid addresses, not real world addresses.
#   $regex =~ s/__EMAIL__       /$RE{Email}{Address}/gx;
#   The empty alternative below is to allow for <> as the sender address
#   We also allow up to 7 @ signs in the address . . . I have seen that many :(
    $regex =~ s/__EMAIL__       /(?:|[^@]+(?:\@(?:__HOSTNAME__|\\[__IP__\\])){0,7})/gx;
    $regex =~ s/__HOSTNAME_IP__ /__HOSTNAME__\[__IP__\]/gx;
    # This doesn't match, for varous reason - I think numeric subnets are one.
    #$regex =~ s/__HOSTNAME__    /$RE{net}{domain}{-nospace}/gx;
    $regex =~ s/__HOSTNAME__    /$hostname_re/gx;
    $regex =~ s/__IP__          /$RE{net}{IPv4}/gx;
    $regex =~ s/__SMTP_CODE__   /\\d{3}/gx;
    # 3-9 is a guess.
    $regex =~ s/__QUEUEID__     /(?:NOQUEUE|[\\dA-F]{3,9})/gx;
    $regex =~ s/__COMMAND__/(?:MAIL FROM|RCPT TO|DATA(?: command)?|message body|end of DATA)/gx;
#   $regex =~ s/____/$RE{}{}/gx;

    return $regex;
}

sub make_connection {
    my ($line) = @_;

    if (exists $connections{$line->{pid}}) {
        my_warn(qq{existing connection hash for pid $line->{pid}; this should never happen :(\n});
    }
    if (not exists $connect_programs{$line->{program}}) {
        my_warn(qq{trying to create a connection for program $line->{program}\n});
    }

    $connections{$line->{pid}} = {};
    return $connections{$line->{pid}};
}

sub disconnection {
    my ($line) = @_;

    if (not exists $connections{$line->{pid}}) {
        my_warn(qq{no connection hash for pid $line->{pid} - perhaps the connect line is in a previous log file?\n});
        return;
    }

    my $connection = $connections{$line->{pid}};
    if (exists $connection->{queueid}
            and $connection->{queueid} eq q{NOQUEUE}) {
        my_warn(qq{$line->{pid}: queueid is NOQUEUE, ignored\n});
        delete $connection->{queueid};
    }

    # This is quite common - it happens every time we reject at SMTP time.
    if (not exists $connection->{queueid} and exists $connection->{results}) {
        commit_connection($connection);
    }

    delete $connections{$line->{pid}};
}

# TODO: write this.  Collapse adjacent sets of results which should be relaxed
# (how will I know this?).  If necessary (and available) pull data from tracked
# connections to suplement the data we have - we don't usually have the sender
# for tracked connections.  Mark the connection as fixuped.
sub fixup_connection {
    my ($connection) = @_;

}

# XXX: THIS ISN'T ACCURATE ANY MORE.
# My logic in relation to smtpd pids and queueids is:
# There has to be a line from smtpd saying "queueid: accepted" or something 
# similar, so we have to have gotten a queueid at some stage, or the mail
# couldn't be in the system at all.  I know this doesn't handle submission by
# sendmail or anything like that, I'll have to figure that bit out later.
sub save {
    my ($line, $rule, $matches) = @_;

    my $queueid     = $matches->[$rule->{queueid}];
    my $connection  = get_connection($line, $queueid, $rule);

    # Ensure we save the connection by queueid; this allows us to tie the whole
    # lot together.
    if ($queueid and not exists $queueids{$queueid}) {
        $queueids{$queueid} = $connection;
    }

    # Clear the faked flag as soon as we see the queueid from a log line
    delete $connection->{faked};

    my $connection_cols = $rule->{connection_cols};
    foreach my $ccol (keys %{$connection_cols}) {
        $connection->{$ccol} = $matches->[$connection_cols->{$ccol}];
    }

    # Believe it or not, I do have rules where nothing is saved in %result
    # except $rule.
    my %result = (
        rule => $rule,
    );
    my $result_cols = $rule->{result_cols};
    foreach my $rcol (keys %{$result_cols}) {
        $result{$rcol} = $matches->[$result_cols->{$rcol}];
    }

    if (not exists $connection->{results}) {
        $connection->{results} = [];
    }
    push @{$connection->{results}}, \%result;
}

sub track {
    my ($line, $rule, $matches) = @_;

    my $queueid         = $matches->[$rule->{queueid}];
    my $connection      = get_connection($line, $queueid, $rule);

    my $new_queueid     = $connection->{new_queueid};
    my $new_connection  = get_connection($line, $new_queueid, $rule);

    if (exists $new_connection->{old_queueid}) {
        my_warn(qq{Trying to track for a second time! (old_queueid exists)\n},
            qq{\tqueueid        => $queueid\n},
            qq{\tnew_queueid    => $new_queueid\n},
            qq{\told_queueid    => $new_connection->{old_queueid}\n},
        );
    }
    # We can't detect tracking for a second time by checking new_queueid,
    # because that's been unconditionally overwritten by save().

    $new_connection->{old_queueid} = $queueid;
    $connection->{new_queueid} = $new_queueid;
}

# TODO: WRITE
sub commit {
    my ($line, $rule, $matches) = @_;

    my $queueid = $matches->[$rule->{queueid}];
    my $connection = get_connection($line, $queueid, $rule);

    if (not $connection) {
        my_warn(qq{no connection for $line->{text}\n});
        return;
    }

    fixup_connection($connection);
    commit_connection($connection);
    $connection->{committed} = 1;
    delete_connection($line, $queueid);
}

# TODO: WRITE
sub commit_connection {
    my ($connection) = @_;

    if ($connection->{faked}) {
        my_warn(qq{commit_connection: trying to commit faked connection\n},
            qq{\tconnection => } . dump_connection($connection) . qq{\n}
        );
    }
}

sub my_warn {
    warn qq{$0: $current_logfile: $.: }, @_;
}

sub my_die {
    die qq{$0: $current_logfile: $.: }, @_;
}

__DATA__

sub save_connection {

    # We're not dealing with success; need to add that later.
    if (not exists $connections
        not @{$connections{$line->{pid}}->{results}}) {
        warn qq{$0: $logfile: $.: no results\n};
        delete $connections{$line->{pid}};
        return;
    }

    $connections{$line->{pid}}->{connection} =
        $dbix->resultset(q{Connection})->new_result({
            start => $line->{timestamp}
        });

        my $check_result = $dbix->resultset(q{Check::Result})->new_result({
            check_id        => $check->{id},
            result          => $result,
#                warning         => 
            smtp_code       => $smtp_code,
            recipient       => $matches[$check->{result_cols}->{recipient}],
            sender          => $matches[$check->{result_cols}->{sender}],
            log_line        => $line->{text},
            data            => $matches[$check->{result_cols}->{data}],
        });
    if ($num_connections_uncommitted > 1000) {
        $dbix->txn_commit();
        $num_connections_uncommitted = 0;
    }
    if (not $num_connections_uncommitted) {
        $dbix->txn_begin();
    }

    my $connection = $connections{$line->{pid}}->{connection};
    $connection->end($line->{timestamp});
    $connection->insert();
    $num_connections_uncommitted++;

    foreach my $result (@{$connections{$line->{pid}}->{results}}) {
        $result->connection_id($connection->id());
        $result->insert();
    }

}
