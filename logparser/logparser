#!/usr/bin/env perl

# $Id$

# NOTES: for successful mail, I get:
#   postfix/smtpd: 6F3D44317: client=webbie.berkeley.intel-research.net[12.155.161.150]
#   postfix/qmgr: 6F3D44317: from=<dtn-interest-admin@mailman.dtnrg.org>, size=11880, nrcpt=2 (queue active)
#   postfix/smtp: 6F3D44317: to=<elizabeth.daly@cs.tcd.ie>, relay=127.0.0.1[127.0.0.1], delay=14, status=sent (250 2.6.0 Ok, id=18003-11, from MTA([127.0.0.1]:11025): 250 Ok: queued as B370843FD)
#   postfix/smtp: 6F3D44317: to=<stephen.farrell@cs.tcd.ie>, relay=127.0.0.1[127.0.0.1], delay=14, status=sent (250 2.6.0 Ok, id=18003-11, from MTA([127.0.0.1]:11025): 250 Ok: queued as B370843FD)
#   postfix/qmgr: 6F3D44317: removed
# That gives me: hostname, ip, sender, recipients (I can sanity check recipient
# number using nrcpt), smtp code, queueid, timestamps, result.
# So far I don't have HELO.  The queueid ties those lines together.  Can I get
# postfix to log the HELO somehow?  There might be cleanup lines too . . . just
# message-id, I think.

use strict;
use warnings;

use lib q{..};
use ASO::DB;
use Parse::Syslog;
use IO::File;
use Carp;
use Data::Dumper;
use Regexp::Common qw(Email::Address net);

my $dbix = ASO::DB->connect(
    q{dbi:SQLite:dbname=../sql/db.sq3},
    {AutoCommit => 0},
);

my @logs = @ARGV;
if (not @logs and -t STDIN) {
    die qq{Usage: $0 logfile [logfiles]\n};
}
if (not @logs) {
    @logs = q{-};
}

my @rules                       = load_rules();
my %rules_by_program            = map { $_->{program} => [] } @rules;
map { push @{$rules_by_program{$_->{program}}}, $_ } @rules;

# programs which can create connections
my %connect_programs        = (
    q{postfix/smtpd}        => 1,
);

my $queueid_regex   = filter_regex(q{^__QUEUEID__$});
$queueid_regex      = qr/$queueid_regex/;

my (%connections, %queueids);
my $num_connections_uncommitted = 0;
my $current_logfile;

foreach my $logfile (@logs) {
    print qq{$0: Starting to read $logfile\n};
    $current_logfile = $logfile;
    my $syslog = Parse::Syslog->new($logfile, year => 2006);
    if (not $syslog) {
        croak qq{Failed creating parser for $logfile: $@\n};
    }

    LINE:
    while (my $line = $syslog->next()) {
        if (not exists $rules_by_program{$line->{program}}) {
            # It's not from a program we're interested in, skip it.
            next LINE;
        }

        # Parse::Syslog handles "last line repeated n times" by returning the 
        # same hash as it did on the last call, so any changes we make to the 
        # contents of the hash will be propogated, thus we need to work on a
        # copy of the text of the line from now on.
        my $text = $line->{text};

        RULE:
        foreach my $rule (@{$rules_by_program{$line->{program}}}) {
            if ($text !~ m/$rule->{regex}/) {
                next RULE;
            }
            $rule->{count}++;

            # XXX: is there a way I can do this without matching twice??
            my @matches = ($text =~ m/$rule->{regex}/);
            # regex matches start at one, but array indices start at 0.
            # shift the array forward so they're aligned
            unshift @matches, undef;

            # A line we want to ignore
            if (uc $rule->{action} eq q{IGNORE}) {
                next LINE;
            }

            # Someone has connected to us
            if (uc $rule->{action} eq q{CONNECT}) {
                my $connection = make_connection_by_pid($line);
                delete $connection->{faked};
                # We also want to save the hostname/ip info
                save($connection, $line, $rule, \@matches);
                next LINE;
            }

            # Someone has disconnected
            if (uc $rule->{action} eq q{DISCONNECT}) {
                disconnection($line);
                next LINE;
            }

            # We want to save some information
            if (uc $rule->{action} eq q{SAVE_BY_PID}) {
                my $connection = get_connection_by_pid($line);
                save($connection, $line, $rule, \@matches);
                next LINE;
            }

            # We want to save some information
            if (uc $rule->{action} eq q{SAVE_BY_QUEUEID}) {
                my $queueid = get_queueid($line, $rule, \@matches);
                my $connection = get_connection_by_queueid($line, $queueid);
                save($connection, $line, $rule, \@matches);
                next LINE;
            }

            # We want to create db entries with the information we've saved.
            if (uc $rule->{action} eq q{COMMIT}) {
                my $queueid = get_queueid($line, $rule, \@matches);
                my $connection = get_connection_by_queueid($line, $queueid);

                $connection->{end} = $line->{timestamp};
                fixup_connection($connection);
                commit_connection($connection);
                $connection->{committed} = 1;
                maybe_delete_by_queueid($connection, $line, $rule);

                next LINE;
            }

            # We need to track a mail across queueids, typically when mail
            # goes through amavisd-new.
            if (uc $rule->{action} eq q{TRACK}) {
                my $queueid = get_queueid($line, $rule, \@matches);
                my $connection = get_connection_by_queueid($line, $queueid);
                # XXX
                save($connection, $line, $rule, \@matches);
                track($line, $rule, \@matches);
                next LINE;
            }

            # We match the start of every restriction line with the same regex,
            # to make restriction rules easier to write.
            # NOTE: we now try the remainder of the rules too, we don't move
            # on to the next line.
            if (uc $rule->{action} eq q{RESTRICTION_START}) {
                $text =~ s/$rule->{regex}//;
                my $connection = get_connection_by_pid($line);
                save($connection, $line, $rule, \@matches);
                next RULE;
            }

            if (uc $rule->{action} eq q{QMGR_CHOOSES_MAIL}) {
                my $connection;
                my $queueid = get_queueid($line, $rule, \@matches);
                if (not exists $queueids{$queueid}) {
                    $connection = make_connection_by_queueid($line, $queueid);
                } else {
                    $connection = get_connection_by_queueid($line, $queueid);
                }
                save($connection, $line, $rule, \@matches);
                next LINE;
            }

            if (uc $rule->{action} eq q{PICKUP}) {
                my $queueid = get_queueid($line, $rule, \@matches);
                my $connection = make_connection_by_queueid($line, $queueid);
                save($connection, $line, $rule, \@matches);
                delete $connection->{faked};
                next LINE;
            }

            if (uc $rule->{action} eq q{CLONE}) {
                my $connection = get_connection_by_pid($line);
                my $clone = { %$connection };
                save($clone, $line, $rule, \@matches);
                next LINE;
            }

            my_warn(qq{unknown action $rule->{action}\n} . Dumper($rule));
        }

        # Last ditch: complain to the user
        print qq{$line->{program}: $text\n};
        #my_warn(qq{unknown line: $line->{program}: $line->{pid}: $text\n});
    }
}
if ($num_connections_uncommitted) {
    $dbix->txn_commit();
}

#print dump_state();
update_check_order();
#print dump_totals();

# Maybe use Text::Table?
sub dump_totals {
    my (%map, $length);
    $length = 0;

    foreach my $rule (@rules) {
        $map{$rule->{name}} = $rule->{count};
        if (length $rule->{name} > $length) {
            $length = length $rule->{name};
        }
    }

    my $result = q{};
    my @names = sort { $map{$b} <=> $map{$a} } keys %map;
    foreach my $name (@names) {
        $result .= $name . (q{ } x (3 + $length - length $name)) . $map{$name} . qq{\n};
    }

    return $result;
}

sub update_check_order {
    my ($i, %order_map) = (1);

    map { exists $_->{count} or $_->{count} = 0 } @rules;
    my @sorted_rules = sort { $b->{count} <=> $a->{count} } @rules;
    foreach my $rule (@sorted_rules) {
        $order_map{$rule->{id}} = $i++;
    }
    foreach my $rule ($dbix->resultset(q{Rule})->search()) {
        # Sometimes a rule won't have been hit; just use the next value
        # in the sequence.
        $rule->rule_order($order_map{$rule->id()} || $i++);
        $rule->update();
    }
}

sub parse_result_data {
    my ($spec, $rule) = @_;

    my $assignments = {};
    foreach my $assign (split /\s*,\s*/, $spec) {
        if (not length $assign) {
            my_warn(qq{parse_result_data: empty assignment found in: \n},
                dump_rule_from_db($rule));
        }
        if ($assign !~ m/^\s*(\w+)\s*=\s*(.+)\s*/) {
            my_warn(qq{parse_result_data: bad assignment found in: \n},
                dump_rule_from_db($rule));
        }
        $assignments->{$1} = $2;
    }
    return $assignments;
}

sub parse_result_cols {
    my ($spec, $rule) = @_;

    my $assignments = {};
    foreach my $assign (split /\s*,\s*/, $spec) {
        if (not length $assign) {
            my_warn(qq{parse_result_cols: empty assignment found in: \n},
                dump_rule_from_db($rule));
        }
        if ($assign !~ m/^\s*(\w+)\s*=\s*(\d+)\s*/) {
            my_warn(qq{parse_result_cols: bad assignment found in: \n},
                dump_rule_from_db($rule));
        }
        $assignments->{$1} = $2;
    }
    return $assignments;
}

# For the moment, this just deletes, but later it'll need to wait until every 
# tracked connection is ready to be committed.
sub maybe_delete_by_queueid {
    my ($connection, $line, $rule) = @_;

    delete $queueids{$connection->{queueid}};
}

sub get_queueid {
    my ($line, $rule, $matches) = @_;

    if (not $rule->{queueid}) {
        my_die(qq{get_queueid: no queueid defined by: } . dump_rule($rule));
    }
    my $queueid     = $matches->[$rule->{queueid}];
    if (not defined $queueid or not $queueid) {
        my_die(qq{get_queueid: no queueid found in: },
            dump_line($line),
            qq{using: },
            dump_rule($rule)
        );
    }
    if ($queueid !~ m/$queueid_regex/) {
        my_die(qq{get_queueid: queueid $queueid doesn't match __QUEUEID__;\n},
            dump_line($line),
            qq{using: },
            dump_rule($rule)
        );
    }

    return $queueid;
}

sub get_connection_by_queueid {
    my ($line, $queueid, @extra_messages) = @_;
    if (not exists $queueids{$queueid}) {
        my_warn(@extra_messages,
            qq{get_connection_by_queueid: no connection for: },
            dump_line($line)
        );
        return make_connection_by_queueid($line, $queueid);
    }
    return $queueids{$queueid};
}

sub get_connection_by_pid {
    my ($line) = @_;
    if (not exists $connections{$line->{pid}}) {
        my_warn(qq{get_connection_by_pid: no connection for: },
            dump_line($line)
        );
        return make_connection_by_pid($line);
    }
    return $connections{$line->{pid}};
}

sub load_rules {
    my @results;

    foreach my $rule ($dbix->resultset(q{Rule})->search()) {
        my $rule_hash = {
            id               => $rule->id(),
            name             => $rule->name(),
            description      => $rule->description(),
            rule_order       => $rule->rule_order(),
            priority         => $rule->priority(),
            result           => $rule->result(),
            action           => $rule->action(),
            program          => $rule->program(),
            queueid          => $rule->queueid(),
            result_cols      => parse_result_cols($rule->result_cols(), $rule),
            connection_cols  => parse_result_cols($rule->connection_cols(), $rule),
            # for the moment we're reusing the result_cols format, but we 
            # remove the restriction limiting the RHS to \d+
            result_data      => parse_result_data($rule->result_data(), $rule),
            connection_data  => parse_result_data($rule->connection_data(), $rule),
        };

        # Compile the regex for efficiency, otherwise it'll be recompiled every
        # time it's used.
        my $regex = filter_regex($rule->regex());
        eval {
            $rule_hash->{regex} = qr/$regex/;
        };
        if ($@) {
            croak qq{$0: failed to compile regex $regex: $@\n} .
                dump_rule_from_db($rule);
        }

        push @results, $rule_hash;
    }
    return sort {      $b->{priority}   <=> $a->{priority} 
                    or $a->{rule_order} <=> $b->{rule_order} } @results;
}

sub dump_connection {
    my ($connection) = @_;

    return Data::Dumper->Dump([$connection], [q{connection}]);
}

sub dump_line {
    my ($line) = @_;

    return Data::Dumper->Dump([$line], [q{line}]);
}

sub dump_rule {
    my ($rule) = @_;

    return Data::Dumper->Dump([$rule], [q{rule}]);
}

sub dump_rule_from_db {
    my ($rule) = @_;

    my %columns = $rule->get_columns();
    return Data::Dumper->Dump([\%columns], [q{rule}]);
}

sub dump_state {
    
    return Data::Dumper->Dump(
        [\%connections, \%queueids],
        [qw(connections queueids)]
    );
}

sub filter_regex {
    my ($regex) = @_;

    # I'm deliberately allowing a trailing .
    my $hostname_re = qr/(?:unknown|(?:[-_a-zA-Z0-9.]+))/;

    $regex =~ s/__SENDER__      /__EMAIL__/gx;
    $regex =~ s/__RECIPIENT__   /__EMAIL__/gx;
    # We see some pretty screwey hostnames in HELO commands.
    $regex =~ s/__HELO__        /__HOSTNAME__|(?:\\[)__IP__(?:\\])|(.*?)/gx;
#   This doesn't work, as it matches valid addresses, not real world addresses.
#   $regex =~ s/__EMAIL__       /$RE{Email}{Address}/gx;
#   The empty alternative below is to allow for <> as the sender address
#   We also allow up to 7 @ signs in the address . . . I have seen that many :(
    $regex =~ s/__EMAIL__       /(?:|[^@]+(?:\@(?:__HOSTNAME__|\\[__IP__\\])){0,7})/gx;
    $regex =~ s/__HOSTNAME_IP__ /__HOSTNAME__\[__IP__\]/gx;
    # This doesn't match, for varous reason - I think numeric subnets are one.
    #$regex =~ s/__HOSTNAME__    /$RE{net}{domain}{-nospace}/gx;
    $regex =~ s/__HOSTNAME__    /$hostname_re/gx;
    $regex =~ s/__IP__          /$RE{net}{IPv4}/gx;
    $regex =~ s/__SMTP_CODE__   /\\d{3}/gx;
    # 3-9 is a guess.
    $regex =~ s/__QUEUEID__     /(?:NOQUEUE|[\\dA-F]{3,9})/gx;
    $regex =~ s/__COMMAND__/(?:MAIL FROM|RCPT TO|DATA(?: command)?|message body|end of DATA)/gx;
#   $regex =~ s/____/$RE{}{}/gx;

    return $regex;
}

sub make_connection_by_queueid {
    my ($line, $queueid) = @_;
    if (exists $queueids{$queueid}) {
        my_warn(qq{make_connection_by_queueid: $queueid already exists},
            dump_line($line)
        );
        return $queueids{$queueid};
    }

    # NOTE: We don't clear the faked flag here, that's up to the caller.
    my $connection = make_connection($line);
    $connection->{queueid} = $queueid;
    $queueids{$queueid} = $connection;
    return $connection;
}

sub make_connection_by_pid {
    my ($line) = @_;
    # NOTE: We don't clear the faked flag here, that's up to the caller.
    my $connection = make_connection($line);
    $connections{$line->{pid}} = $connection;
    return $connection;
}

sub make_connection {
    my ($line) = @_;

    return {
        start => $line->{timestamp},
        faked => $line,
    };
}

sub disconnection {
    my ($line) = @_;

    if (not exists $connections{$line->{pid}}) {
        my_warn(qq{disconnection: no connection for pid $line->{pid} - perhaps the connect line is in a previous log file?\n});
        return;
    }

    my $connection = $connections{$line->{pid}};
    # This is quite common - it happens every time we reject at SMTP time.
    if (not exists $connection->{queueid} and exists $connection->{results}) {
        $connection->{end} = $line->{timestamp};
        fixup_connection($connection);
        commit_connection($connection);
    }

    delete $connections{$line->{pid}};
}

sub get_mock_object {
    my ($table) = @_;
    return $dbix->resultset($table)->new_result({});
}

sub make_hash {
    return map { $_ => 1 } @_;
}

# TODO: If necessary (and available) pull data from tracked
# connections to suplement the data we have - we don't usually have the sender
# for tracked connections.  Mark the connection as fixuped.
sub fixup_connection {
    my ($connection)                = @_;
    my $results                     = $connection->{results};
    my $fake_result                 = get_mock_object(q{Result});
    my $fake_connection             = get_mock_object(q{Connection});
    my %required_connection_cols    = make_hash($fake_connection->required_columns());
    my %required_result_cols        = make_hash($fake_result->required_columns());
    my %nochange_result_cols        = make_hash($fake_result->nochange_columns());


    my %data;
    # Populate %data.
    foreach my $result (@{$results}) {
        foreach my $key (keys %{$result}) {
            if (exists $nochange_result_cols{$key}
                and exists $data{$key}
                and $data{$key} ne $result->{$key}) {
                my_warn(qq{fixup_connection: Different values for $key: \n}
                    . qq{\told: $data{$key}\n}
                    . qq{\tnew: $result->{$key}\n}
                );
            }
            $data{$key} = $result->{$key};
        }
    }

    # Check that we have everything we need
    RESULT:
    foreach my $result (@{$results}) {
        if (uc $result->{result} eq q{INFO}) {
            next RESULT;
        }
        foreach my $rcol (keys %required_result_cols) {
            if (not exists $result->{$rcol}) {
                if (exists $data{$rcol}) {
                    $result->{$rcol} = $data{$rcol};
                } else {
# XXX ADD THESE BACK IN
#                    my_warn(qq{fixup_connection: missing result col: $rcol\n},
#                        dump_connection($connection),
#                    );
                }
            }
        }
    }

    foreach my $ccol (keys %required_connection_cols) {
        if (not exists $connection->{$ccol}) {
# XXX ADD THESE BACK IN
#            my_warn(qq{fixup_connection: missing connection col: $ccol\n},
#                dump_connection($connection),
#            );
        }
    }
}

# XXX: THIS ISN'T ACCURATE ANY MORE.
# My logic in relation to smtpd pids and queueids is:
# There has to be a line from smtpd saying "queueid: accepted" or something 
# similar, so we have to have gotten a queueid at some stage, or the mail
# couldn't be in the system at all.  I know this doesn't handle submission by
# sendmail or anything like that, I'll have to figure that bit out later.
sub save {
    my ($connection, $line, $rule, $matches) = @_;

    my $c_data = $rule->{connection_data};
    map { $connection->{$_} = $c_data->{$_} } keys %{$c_data};
    my $c_cols = $rule->{connection_cols};
    map { $connection->{$_} = $matches->[$c_cols->{$_}] } keys %{$c_cols};

    my %result = (
        #rule    => $rule,
        rule_id => $rule->{id},
        result  => $rule->{result},
        line    => $line,
    );
    my $r_data = $rule->{result_data};
    map { $result{$_} = $r_data->{$_} } keys %{$r_data};
    my $r_cols = $rule->{result_cols};
    map { $result{$_} = $matches->[$r_cols->{$_}] } keys %{$r_cols};

    if (not exists $connection->{results}) {
        $connection->{results} = [];
    }
    push @{$connection->{results}}, \%result;

    # XXX WHERE SHOULD I DO THIS?  Should it be based on ACCEPT?
    # Ensure we save the connection by queueid; this allows us to tie the whole
    # lot together.
    if ($connection->{queueid} and not exists $queueids{$connection->{queueid}}) {
        $queueids{$connection->{queueid}} = $connection;
    }
}

sub track {
    my ($line, $rule, $matches) = @_;

    my $queueid         = get_queueid($line, $rule, $matches);
    my $connection      = get_connection_by_queueid($line, $queueid);

    my $new_queueid     = $connection->{new_queueid};
    my $new_connection;
    if (exists $queueids{$new_queueid}) {
        $new_connection = $queueids{$new_queueid};
    } else {
        $new_connection = make_connection_by_queueid($line, $new_queueid);
    }
    # Clear the faked flag; this is good when we haven't seen the connection
    # yet, but bad when the connection has been and gone.
    delete $new_connection->{faked};

    if (exists $new_connection->{old_queueid}
        and $new_connection->{old_queueid} ne $queueid) {
        my_warn(qq{Trying to track for a second time! (old_queueid differs)\n},
            qq{\tqueueid (new_queueid->old_queueid) => $queueid\n},
            qq{\tnew_queueid                        => $new_queueid\n},
            qq{\told_queueid                        => $new_connection->{old_queueid}\n},
            qq{\t$line->{program}: $line->{text}\n},
        );
    }
    # We can't detect tracking for a second time by checking new_queueid,
    # because that's been unconditionally overwritten by save().

    $new_connection->{old_queueid} = $queueid;
    $connection->{new_queueid} = $new_queueid;
}

# TODO: WRITE
sub commit_connection {
    my ($connection) = @_;

    if ($connection->{faked}) {
        my_warn(qq{commit_connection: faked connection: \n},
            dump_connection($connection)
        );
    }
}

sub my_warn {
    warn qq{$0: $current_logfile: $.: }, @_;
}

sub my_die {
    die qq{$0: $current_logfile: $.: }, @_;
}

__DATA__

sub save_connection {

    # We're not dealing with success; need to add that later.
    if (not exists $connections
        not @{$connections{$line->{pid}}->{results}}) {
        warn qq{$0: $logfile: $.: no results\n};
        delete $connections{$line->{pid}};
        return;
    }

    $connections{$line->{pid}}->{connection} =
        $dbix->resultset(q{Connection})->new_result({
            start => $line->{timestamp}
        });

        my $check_result = $dbix->resultset(q{Check::Result})->new_result({
            check_id        => $check->{id},
            result          => $result,
#                warning         => 
            smtp_code       => $smtp_code,
            recipient       => $matches[$check->{result_cols}->{recipient}],
            sender          => $matches[$check->{result_cols}->{sender}],
            log_line        => $line->{text},
            data            => $matches[$check->{result_cols}->{data}],
        });
    if ($num_connections_uncommitted > 1000) {
        $dbix->txn_commit();
        $num_connections_uncommitted = 0;
    }
    if (not $num_connections_uncommitted) {
        $dbix->txn_begin();
    }

    my $connection = $connections{$line->{pid}}->{connection};
    $connection->end($line->{timestamp});
    $connection->insert();
    $num_connections_uncommitted++;

    foreach my $result (@{$connections{$line->{pid}}->{results}}) {
        $result->connection_id($connection->id());
        $result->insert();
    }

}
