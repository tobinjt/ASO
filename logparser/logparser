#!/usr/bin/env perl

# $Id$

# NOTES: for successful mail, I get:
#   postfix/smtpd: 6F3D44317: client=webbie.berkeley.intel-research.net[12.155.161.150]
#   postfix/qmgr: 6F3D44317: from=<dtn-interest-admin@mailman.dtnrg.org>, size=11880, nrcpt=2 (queue active)
#   postfix/smtp: 6F3D44317: to=<elizabeth.daly@cs.tcd.ie>, relay=127.0.0.1[127.0.0.1], delay=14, status=sent (250 2.6.0 Ok, id=18003-11, from MTA([127.0.0.1]:11025): 250 Ok: queued as B370843FD)
#   postfix/smtp: 6F3D44317: to=<stephen.farrell@cs.tcd.ie>, relay=127.0.0.1[127.0.0.1], delay=14, status=sent (250 2.6.0 Ok, id=18003-11, from MTA([127.0.0.1]:11025): 250 Ok: queued as B370843FD)
#   postfix/qmgr: 6F3D44317: removed
# That gives me: hostname, ip, sender, recipients (I can sanity check recipient
# number using nrcpt), smtp code, queueid, timestamps, result.
# So far I don't have HELO.  The queueid ties those lines together.  Can I get
# postfix to log the HELO somehow?  There might be cleanup lines too . . . just
# message-id, I think.

use strict;
use warnings;
$| = 1;

use lib q{..};
use ASO::DB;
use Parse::Syslog;
use IO::File;
use Carp;
use Data::Dumper;
use Regexp::Common qw(Email::Address net);
use Storable qw(dclone);

my $dbix = ASO::DB->connect(
    q{dbi:SQLite:dbname=../sql/db.sq3},
    {AutoCommit => 0},
);

my @logs = @ARGV;
if (not @logs and -t STDIN) {
    die qq{Usage: $0 logfile [logfiles]\n};
}
if (not @logs) {
    @logs = q{-};
}

my @rules                       = load_rules();
my %rules_by_program            = map { $_->{program} => [] } @rules;
map { push @{$rules_by_program{$_->{program}}}, $_ } @rules;

# programs which can create connections
my %connect_programs        = (
    q{postfix/smtpd}        => 1,
);

my $queueid_regex   = filter_regex(q{^__QUEUEID__$});
$queueid_regex      = qr/$queueid_regex/;

my (%connections, %queueids);
my $num_connections_uncommitted = 0;
my $current_logfile;

# Save the startup times seperately, when profiling with Devel::Profile.
devel_profile_startup();

foreach my $logfile (@logs) {
    print qq{$0: Starting to read $logfile\n};
    $current_logfile = $logfile;
    my $syslog = Parse::Syslog->new($logfile, year => 2006);
    if (not $syslog) {
        croak qq{Failed creating parser for $logfile: $@\n};
    }

    LINE:
    while (my $line = $syslog->next()) {
        if (not exists $rules_by_program{$line->{program}}) {
            # It's not from a program we're interested in, skip it.
            next LINE;
        }
        parse_line($line);
    }
}

if ($num_connections_uncommitted) {
    $dbix->txn_commit();
}
update_check_order();

# Dump any remaining connections so we can tell when we're missing something.
if (%connections) {
    print qq{Dumping mails from \%connections:\n};
    foreach my $pid (sort keys %connections) {
        print qq(pid: $pid {{{1\n),
            dump_connection($connections{$pid}),
            qq(}}}\n);
    }
}
if (%queueids) {
    print qq{Dumping mails from \%queueids:\n};
    foreach my $queueid (sort keys %queueids) {
        print qq(queueid: $queueid {{{\n),
            dump_connection($queueids{$queueid}),
            qq(}}}\n);
    }
}
#print dump_state();
#print dump_totals();
redirect_stdout();

# Maybe use Text::Table?
sub dump_totals {
    my (%map, $length);
    $length = 0;

    foreach my $rule (@rules) {
        $map{$rule->{name}} = $rule->{count};
        if (length $rule->{name} > $length) {
            $length = length $rule->{name};
        }
    }

    my $result = q{};
    my @names = sort { $map{$b} <=> $map{$a} } keys %map;
    foreach my $name (@names) {
        $result .= $name . (q{ } x (3 + $length - length $name)) . $map{$name} . qq{\n};
    }

    return $result;
}

sub update_check_order {
    my ($i, %order_map) = (1);

    map { exists $_->{count} or $_->{count} = 0 } @rules;
    my @sorted_rules = sort { $b->{count} <=> $a->{count} } @rules;
    foreach my $rule (@sorted_rules) {
        $order_map{$rule->{id}} = $i++;
    }
    foreach my $rule ($dbix->resultset(q{Rule})->search()) {
        # Sometimes a rule won't have been hit; just use the next value
        # in the sequence.
        $rule->rule_order($order_map{$rule->id()} || $i++);
        $rule->update();
    }
}

sub parse_result_data {
    my ($spec, $rule) = @_;

    my $assignments = {};
    foreach my $assign (split /\s*,\s*/, $spec) {
        if (not length $assign) {
            my_warn(qq{parse_result_data: empty assignment found in: \n},
                dump_rule_from_db($rule));
        }
        if ($assign !~ m/^\s*(\w+)\s*=\s*(.+)\s*/) {
            my_warn(qq{parse_result_data: bad assignment found in: \n},
                dump_rule_from_db($rule));
        }
        $assignments->{$1} = $2;
    }
    return $assignments;
}

sub parse_result_cols {
    my ($spec, $rule) = @_;

    my $assignments = {};
    foreach my $assign (split /\s*,\s*/, $spec) {
        if (not length $assign) {
            my_warn(qq{parse_result_cols: empty assignment found in: \n},
                dump_rule_from_db($rule));
        }
        if ($assign !~ m/^\s*(\w+)\s*=\s*(\d+)\s*/) {
            my_warn(qq{parse_result_cols: bad assignment found in: \n},
                dump_rule_from_db($rule));
        }
        $assignments->{$1} = $2;
    }
    return $assignments;
}

sub parse_line {
    my ($line) = @_;
    # Parse::Syslog handles "last line repeated n times" by returning the 
    # same hash as it did on the last call, so any changes we make to the 
    # contents of the hash will be propogated, thus we need to work on a
    # copy of the text of the line from now on.
    my $text = $line->{text};

    RULE:
    foreach my $rule (@{$rules_by_program{$line->{program}}}) {
        if ($text !~ m/$rule->{regex}/) {
            next RULE;
        }
        $rule->{count}++;

        # TODO: is there a way I can do this without matching twice??
        my @matches = ($text =~ m/$rule->{regex}/);
        # regex matches start at one, but array indices start at 0.
        # shift the array forward so they're aligned
        unshift @matches, undef;

        # A line we want to ignore
        if (uc $rule->{action} eq q{IGNORE}) {
            return;
        }

        # Someone has connected to us
        if (uc $rule->{action} eq q{CONNECT}) {
            my $connection = make_connection_by_pid($line);
            delete $connection->{faked};
            # We also want to save the hostname/ip info
            save($connection, $line, $rule, \@matches);
            return;
        }

        # Someone has disconnected
        if (uc $rule->{action} eq q{DISCONNECT}) {
            disconnection($line);
            return;
        }

        # We want to save some information
        if (uc $rule->{action} eq q{SAVE_BY_PID}) {
            my $connection = get_connection_by_pid($line);
            save($connection, $line, $rule, \@matches);
            return;
        }

        # We want to save some information
        if (uc $rule->{action} eq q{SAVE_BY_QUEUEID}) {
            my $queueid = get_queueid($line, $rule, \@matches);
            my $connection = get_connection_by_queueid($line, $queueid);
            save($connection, $line, $rule, \@matches);
            return;
        }

        # We want to create db entries with the information we've saved.
        if (uc $rule->{action} eq q{COMMIT}) {
            my $queueid = get_queueid($line, $rule, \@matches);
            my $connection = get_connection_by_queueid($line, $queueid);

            save($connection, $line, $rule, \@matches);
            $connection->{end} = $line->{timestamp};
            if (exists $connection->{faked}) {
                # I'm assuming that anything marked as faked is waiting to be
                # track()ed, and will be dealt with by committing tracked
                # connections later; mark it so we know it's reached commitment
                # and can be tried again.
                $connection->{commit_reached} = 1;
                return;
            }
            fixup_connection($connection);
            commit_connection($connection);
            maybe_delete_by_queueid($connection, $line, $rule);

            return;
        }

        # We need to track a mail across queueids, typically when mail
        # goes through amavisd-new.
        if (uc $rule->{action} eq q{TRACK}) {
            my $queueid = get_queueid($line, $rule, \@matches);
            my $connection = get_connection_by_queueid($line, $queueid);
            save($connection, $line, $rule, \@matches);
            track($line, $rule, \@matches);
            return;
        }

        # We match the start of every restriction line with the same regex,
        # to make restriction rules easier to write.
        # NOTE: we now try the remainder of the rules too, we don't move
        # on to the next line.
        if (uc $rule->{action} eq q{RESTRICTION_START}) {
            $text =~ s/$rule->{regex}//;
            my $connection = get_connection_by_pid($line);
            save($connection, $line, $rule, \@matches);
            next RULE;
        }

        if (uc $rule->{action} eq q{QMGR_CHOOSES_MAIL}) {
            my $connection;
            my $queueid = get_queueid($line, $rule, \@matches);
            # XXX why do I make connections?  They should exist.
            if (not exists $queueids{$queueid}) {
                $connection = make_connection_by_queueid($line, $queueid);
            } else {
                $connection = get_connection_by_queueid($line, $queueid);
            }
            save($connection, $line, $rule, \@matches);
            return;
        }

        if (uc $rule->{action} eq q{PICKUP}) {
            my $queueid = get_queueid($line, $rule, \@matches);
            my $connection = make_connection_by_queueid($line, $queueid);
            save($connection, $line, $rule, \@matches);
            delete $connection->{faked};
            return;
        }

        # Create a deep copy of the connection and save it by queueid so that
        # subsequent mails sent on this connection don't clobber each other.
        if (uc $rule->{action} eq q{CLONE}) {
            my $connection = get_connection_by_pid($line);
            my $clone = dclone($connection);
            save($clone, $line, $rule, \@matches);
            return;
        }

        my_warn(qq{unknown action $rule->{action}\n}, dump_rule($rule));
    }

    # Last ditch: complain to the user
    print qq{$line->{program}: $text\n};
}

# For the moment, this just deletes, but later it'll need to wait until every 
# tracked connection is ready to be committed.
sub maybe_delete_by_queueid {
    my ($connection, $line, $rule) = @_;

    if (exists $connection->{faked}) {
        my_warn(qq{maybe_delete_by_queueid: faked connection: \n},
            dump_connection($connection)
        );
        return;
    }
    if (not exists $connection->{fixuped}) {
        my_warn(qq{maybe_delete_by_queueid: non-fixuped connection: \n},
            dump_connection($connection)
        );
        return;
    }
    if (not exists $connection->{committed}) {
        my_warn(qq{maybe_delete_by_queueid: uncommitted connection: \n},
            dump_connection($connection)
        );
        return;
    }

    # Let the parent know we're being deleted
    if (exists $connection->{parent}) {
        maybe_delete_parent($connection, $line, $rule);
    }

    # Try to commit any children we can.
    if (exists $connection->{children} and %{$connection->{children}}) {
        maybe_commit_children($connection, $line, $rule);
    }

    if (exists $connection->{children} and %{$connection->{children}}) {
        # Don't delete it yet, there are tracked connections yet to be dealt
        # with.  When the last child is deleted the final call to
        # maybe_delete_parent() will delete this connection.
        $connection->{waiting_for_children} = 1;
        return;
    }

    # This seems pointless, but it may help identify deleted connections which
    # live on because there's a reference to them elsewhere.  I'd need something
    # which walks all the variables remaining at the end of execution to find
    # them though,
    $connection->{deleted} = 1;
    delete $queueids{$connection->{queueid}};
}

sub maybe_commit_children {
    my ($connection, $line, $rule) = @_;

    # We check for this in maybe_delete_parent(), so that we don't trample over
    # ourselves.
    $connection->{committing_children} = 1;

    CHILD:
    foreach my $child (keys %{$connection->{children}}) {
#my_warn(qq{maybe_commit_children: searching for $child\n});
        my $child_con = get_connection_by_queueid($line, $child, 1,
            qq{maybe_commit_children: parent $connection->{queueid} }
            . qq{trying to find child $child});
        if (not defined $child_con) {
            my_warn(qq{maybe_commit_children: missing child $child\n});
            next CHILD;
        }

        if (exists $child_con->{commit_reached}) {
            # We deliberately don't check for success here; there's nothing we
            # can do at this stage.  These are children which weren't being
            # tracked when the yreached commit, so they were still faked - see
            # the check in the COMMIT action in parse_line().
            fixup_connection($child_con);
            commit_connection($child_con);
            maybe_delete_by_queueid($child_con, $line, $rule);
            # This is safe: see perldoc -f each for the guarantee.
            delete $connection->{children}->{$child};
        }

        # We don't do anything with other children, they'll reach committal by
        # themselves later,
    }

    delete $connection->{committing_children};
}

sub maybe_delete_parent {
    my ($connection, $line, $rule) = @_;
    # It's the child in the relationship, not the child of the connection.
    my $child = $connection->{queueid};

    if (not exists $connection->{parent}) {
        my_warn(qq{maybe_delete_parent: missing parent:\n},
            dump_connection($connection));
        return;
    }

    my $parent_con = get_connection_by_queueid($line, $connection->{parent},
        1, qq{maybe_delete_parent: trying to find parent\n});
    if (not defined $parent_con) {
        my_warn(qq{maybe_delete_parent: missing parent $connection->{parent}\n},
            dump_connection($connection));
        return;
    }

    # maybe_commit_children() -> maybe_delete_by_queueid() -> maybe_delete_parent()
    # We don't want to trample over maybe_commit_children().
    if (exists $parent_con->{committing_children}) {
        return;
    }

    if (not exists $parent_con->{children}
            or not exists $parent_con->{children}->{$child}) {
        my_warn(qq{maybe_delete_parent: $child not found in \%children:\n},
            qq{parent: },
            dump_connection($parent_con),
            qq{child: },
            dump_connection($connection));
        return;
    }

    delete $parent_con->{children}->{$child};

    if (not %{$parent_con->{children}}
            and exists $parent_con->{waiting_for_children}) {
        # All the children are gone, and the parent has been committed.
        maybe_delete_by_queueid($parent_con, $line, $rule);
    }
}

sub get_queueid {
    my ($line, $rule, $matches) = @_;

    if (not $rule->{queueid}) {
        my_die(qq{get_queueid: no queueid defined by: } . dump_rule($rule));
    }
    my $queueid     = $matches->[$rule->{queueid}];
    if (not defined $queueid or not $queueid) {
        my_die(qq{get_queueid: no queueid found in: },
            dump_line($line),
            qq{using: },
            dump_rule($rule)
        );
    }
    if ($queueid !~ m/$queueid_regex/) {
        my_die(qq{get_queueid: queueid $queueid doesn't match __QUEUEID__;\n},
            dump_line($line),
            qq{using: },
            dump_rule($rule)
        );
    }

    return $queueid;
}

sub get_connection_by_queueid {
    my ($line, $queueid, $dont_fake, @extra_messages) = @_;
    if (not exists $queueids{$queueid}) {
        my_warn(@extra_messages,
            qq{get_connection_by_queueid: no connection for: },
            dump_line($line)
        );
        if ($dont_fake) {
            return;
        }
        return make_connection_by_queueid($line, $queueid);
    }
    return $queueids{$queueid};
}

sub get_connection_by_pid {
    my ($line) = @_;
    if (not exists $connections{$line->{pid}}) {
        my_warn(qq{get_connection_by_pid: no connection for: },
            dump_line($line)
        );
        return make_connection_by_pid($line);
    }
    return $connections{$line->{pid}};
}

sub load_rules {
    my @results;

    foreach my $rule ($dbix->resultset(q{Rule})->search()) {
        my $rule_hash = {
            id               => $rule->id(),
            name             => $rule->name(),
            description      => $rule->description(),
            rule_order       => $rule->rule_order(),
            priority         => $rule->priority(),
            result           => $rule->result(),
            action           => $rule->action(),
            program          => $rule->program(),
            queueid          => $rule->queueid(),
            result_cols      => parse_result_cols($rule->result_cols(), $rule),
            connection_cols  => parse_result_cols($rule->connection_cols(), $rule),
            # for the moment we're reusing the result_cols format, but we 
            # remove the restriction limiting the RHS to \d+
            result_data      => parse_result_data($rule->result_data(), $rule),
            connection_data  => parse_result_data($rule->connection_data(), $rule),
        };

        # Compile the regex for efficiency, otherwise it'll be recompiled every
        # time it's used.
        my $regex = filter_regex($rule->regex());
        eval {
            $rule_hash->{regex} = qr/$regex/;
        };
        if ($@) {
            croak qq{$0: failed to compile regex $regex: $@\n} .
                dump_rule_from_db($rule);
        }

        push @results, $rule_hash;
    }
    return sort {      $b->{priority}   <=> $a->{priority} 
                    or $a->{rule_order} <=> $b->{rule_order} } @results;
}

sub dump_connection {
    my ($connection) = @_;

    return Data::Dumper->Dump([$connection], [q{connection}]);
}

sub dump_line {
    my ($line) = @_;

    return Data::Dumper->Dump([$line], [q{line}]);
}

sub dump_rule {
    my ($rule) = @_;

    return Data::Dumper->Dump([$rule], [q{rule}]);
}

sub dump_rule_from_db {
    my ($rule) = @_;

    my %columns = $rule->get_columns();
    return Data::Dumper->Dump([\%columns], [q{rule}]);
}

sub dump_state {
    
    return Data::Dumper->Dump(
        [\%connections, \%queueids],
        [qw(connections queueids)]
    );
}

sub filter_regex {
    my ($regex) = @_;

    # I'm deliberately allowing a trailing .
    my $hostname_re = qr/(?:unknown|(?:[-_a-zA-Z0-9.]+))/;

    $regex =~ s/__SENDER__      /__EMAIL__/gx;
    $regex =~ s/__RECIPIENT__   /__EMAIL__/gx;
    # We see some pretty screwey hostnames in HELO commands.
    $regex =~ s/__HELO__        /__HOSTNAME__|(?:\\[)__IP__(?:\\])|(.*?)/gx;
#   This doesn't work, as it matches valid addresses, not real world addresses.
#   $regex =~ s/__EMAIL__       /$RE{Email}{Address}/gx;
#   The empty alternative below is to allow for <> as the sender address
#   We also allow up to 7 @ signs in the address . . . I have seen that many :(
    $regex =~ s/__EMAIL__       /(?:|[^@]+(?:\@(?:__HOSTNAME__|\\[__IP__\\])){0,7})/gx;
    $regex =~ s/__HOSTNAME_IP__ /__HOSTNAME__\[__IP__\]/gx;
    # This doesn't match, for varous reason - I think numeric subnets are one.
    #$regex =~ s/__HOSTNAME__    /$RE{net}{domain}{-nospace}/gx;
    $regex =~ s/__HOSTNAME__    /$hostname_re/gx;
    $regex =~ s/__IP__          /$RE{net}{IPv4}/gx;
    $regex =~ s/__SMTP_CODE__   /\\d{3}/gx;
    # 3-9 is a guess.
    $regex =~ s/__QUEUEID__     /(?:NOQUEUE|[\\dA-F]{3,9})/gx;
    $regex =~ s/__COMMAND__/(?:MAIL FROM|RCPT TO|DATA(?: command)?|message body|end of DATA)/gx;
#   $regex =~ s/____/$RE{}{}/gx;

    return $regex;
}

sub make_connection_by_queueid {
    my ($line, $queueid) = @_;
    if (exists $queueids{$queueid}) {
        my_warn(qq{make_connection_by_queueid: $queueid already exists},
            dump_line($line)
        );
        return $queueids{$queueid};
    }

    # NOTE: We don't clear the faked flag here, that's up to the caller.
    my $connection = make_connection($line);
    $connection->{queueid} = $queueid;
    $queueids{$queueid} = $connection;
    return $connection;
}

sub make_connection_by_pid {
    my ($line) = @_;
    # NOTE: We don't clear the faked flag here, that's up to the caller.
    my $connection = make_connection($line);
    $connections{$line->{pid}} = $connection;
    return $connection;
}

sub make_connection {
    my ($line) = @_;

    return {
        start           => $line->{timestamp},
        faked           => $line,
        # We'll always start with client = localhost, because I can't figure 
        # out which rule should set these initially without clobbering 
        # something else.
        client_hostname => q{localhost},
        client_ip       => q{127.0.0.1},
    };
}

sub disconnection {
    my ($line) = @_;

    # NOTE: We deliberately don't use get_connection_by_pid() here because we
    # don't want a new connection returned, we need more control.
    if (not exists $connections{$line->{pid}}) {
        my_warn(qq{disconnection: no connection for pid $line->{pid} - perhaps the connect line is in a previous log file?\n});
        return;
    }

    my $connection = $connections{$line->{pid}};
    # This is quite common - it happens every time we reject at SMTP time.
    if (not exists $connection->{queueid} and exists $connection->{results}) {
        $connection->{end} = $line->{timestamp};
        fixup_connection($connection);
        commit_connection($connection);
    }

    delete $connections{$line->{pid}};
}

sub get_mock_object {
    my ($table) = @_;
    return $dbix->resultset($table)->new_result({});
}

sub make_hash {
    return map { $_ => 1 } @_;
}

# Update the values in a hash, complaining if we change existing values, unless
# the existing (key, value) is found in silent_overwrite.
sub update_hash {
    my ($hash, $silent_overwrite, $updates, $silent_discard, $rule, $line,
        $connection, $message) = @_;
    my $conflicts = 0;

    UPDATE:
    while (my ($key, $value) = each %{$updates}) {
        if (exists $hash->{$key} 
            and exists $silent_discard->{$key}
            and exists $silent_discard->{$key}->{$value}) {
            # The update is a default value, and shouldn't clobber the existing
            # value: skip it.
            next UPDATE;
        }

        if (exists $hash->{$key} and $hash->{$key} ne $value) {
            my $orig_value = $hash->{$key};
            my $skip_warning = 0;
            # If $key exists, and there are no restrictions on values which can
            # be overwritten, then don't warn.
            if (exists $silent_overwrite->{$key}
                    and not defined $silent_overwrite->{$key}) {
                $skip_warning++;
            }
            # If the existing value can be silently overwritten (i.e. is a
            # default value) then silently overwrite it.
            if (exists $silent_overwrite->{$key}
                    and exists $silent_overwrite->{$key}->{$orig_value}) {
                $skip_warning++;
            }
            if (not $skip_warning) {
                my $warning = $message;
                $warning =~ s/__KEY__/$key/;
                $warning =~ s/__ORIG_VALUE__/$orig_value/;
                $warning =~ s/__NEW_VALUE__/$value/;
                my_warn($warning);
                $conflicts++;
            }
        }

        $hash->{$key} = $value;
    }

    if ($conflicts) {
        my_warn(qq{This rule produced conflicts: \n},
            dump_rule($rule),
            qq{in this line:\n},
            dump_line($line),
            qq{for this connection:\n},
            dump_connection($connection),
        );
    }

    return $conflicts;
}

# TODO: If necessary (and available) pull data from tracked
# connections to suplement the data we have - we don't usually have the sender
# for tracked connections.  Mark the connection as fixuped.
sub fixup_connection {
    my ($connection)                = @_;
    my $results                     = $connection->{results};
    my $fake_result                 = get_mock_object(q{Result});
    my $fake_connection             = get_mock_object(q{Connection});
    my %required_connection_cols    = make_hash($fake_connection->required_columns());
    my %required_result_cols        = make_hash($fake_result->required_columns());
    my %nochange_result_cols        = make_hash($fake_result->nochange_columns());

    # Don't even try if it's faked; faked more or less (I hope) means that it's
    # the latter part of a tracked connection which hasn't been tracked yet, so
    # it should be retried later with the faked flag cleared.
    if (exists $connection->{faked}) {
        my_warn(qq{fixup_connection: faked connection: \n},
            dump_connection($connection)
        );
        return;
    }

    my $parent_con;
    if (exists $connection->{parent}) {
        $parent_con = get_connection_by_queueid(undef, $connection->{parent},
            1, qq{fixup_connection: searching for $connection->{parent}, }
                . qq{parent of $connection->{queueid}\n});
    }

    my $failure = 0;
    my %data;
    # Populate %data.
    foreach my $result (@{$results}) {
        foreach my $key (keys %{$result}) {
            if (exists $nochange_result_cols{$key}
                and exists $data{$key}
                and $data{$key} ne $result->{$key}) {
                my_warn(qq{fixup_connection: Different values for $key: \n}
                    . qq{\told: $data{$key}\n}
                    . qq{\tnew: $result->{$key}\n}
                );
            }
            $data{$key} = $result->{$key};
        }
    }

    # Check that we have everything we need; we can't pull any of this from the
    # parent, I think.  Maybe I can?  I don't need to, at least at this stage.
    RESULT:
    foreach my $result (@{$results}) {
        if (uc $result->{result} eq q{INFO}) {
            next RESULT;
        }
        foreach my $rcol (keys %required_result_cols) {
            if (not exists $result->{$rcol}) {
                if (exists $data{$rcol}) {
                    $result->{$rcol} = $data{$rcol};
                } else {
                    my_warn(qq{fixup_connection: missing result col: $rcol\n},
                        dump_connection($connection),
                    );
                    $failure++;
                }
            }
        }
    }

    foreach my $ccol (keys %required_connection_cols) {
        # NOTE: I'm assuming that anything we're going to require from the
        # parent connection has already been saved there; if not I'll need to
        # revisit this and complicate it much further.
        if (not exists $connection->{$ccol}
                and defined $parent_con
                and exists $parent_con->{$ccol}) {
            $connection->{$ccol} = $parent_con->{$ccol};
        }
        if (not exists $connection->{$ccol}) {
            my_warn(qq{fixup_connection: missing connection col: $ccol\n},
                dump_connection($connection),
            );
            $failure++;
        }
    }

    if ($failure) {
        my_warn(qq{fixup_connection: fixup failed\n});
    } else {
        $connection->{fixuped} = 1;
    }
}

sub save {
    my ($connection, $line, $rule, $matches) = @_;

    # Save the new result.
    my %result = (
        #rule    => $rule,
        rule_id => $rule->{id},
        result  => $rule->{result},
        line    => $line,
    );
    if (not exists $connection->{results}) {
        $connection->{results} = [];
    }
    push @{$connection->{results}}, \%result;

    # Populate %result
    update_hash(\%result, {}, $rule->{result_data}, {}, $rule, $line,
        $connection, <<"DIFFERS");
save: result_data: new value for __KEY__ (__NEW_VALUE__) differs from existing value (__ORIG_VALUE__)
DIFFERS

    my %r_cols_updates = map { $_ => $matches->[$rule->{result_cols}->{$_}] }
        keys %{$rule->{result_cols}};
    update_hash(\%result, {}, \%r_cols_updates, {}, $rule, $line, $connection,
        <<"DIFFERS");
save: result_cols: new value for __KEY__ (__NEW_VALUE__) differs from existing value (__ORIG_VALUE__)
DIFFERS

    # Populate connection.
    my %c_cols_silent_overwrite = (
        client_ip       => {
            q{127.0.0.1}    => 1,
            q{::1}          => 1,
        },
        client_hostname => {
            q{localhost}    => 1,
        },
        server_ip       => undef,
        server_hostname => undef,
    );

    update_hash($connection, \%c_cols_silent_overwrite,
        $rule->{connection_data}, \%c_cols_silent_overwrite,
        $rule, $line, $connection, <<"DIFFERS");
save: connection_data: new value for __KEY__ (__NEW_VALUE__) differs from existing value (__ORIG_VALUE__)
DIFFERS

    my %c_cols_updates = map { $_ => $matches->[$rule->{connection_cols}->{$_}] }
        keys %{$rule->{connection_cols}};
    update_hash($connection, \%c_cols_silent_overwrite, \%c_cols_updates, {},
        $rule, $line, $connection, <<"DIFFERS");
save: connection_cols: new value for __KEY__ (__NEW_VALUE__) differs from existing value (__ORIG_VALUE__)
DIFFERS

    # XXX WHERE SHOULD I DO THIS?  Should it be based on ACCEPT?
    if (exists $connection->{queueid}
            and exists $queueids{$connection->{queueid}}
            and $connection ne $queueids{$connection->{queueid}}) {
        my_warn(qq{save: queueid clash:\n},
            qq{old:\n},
            dump_connection($queueids{$connection->{queueid}}),
            qq{new:\n},
            dump_connection($connection),
        );
    }
    # Ensure we save the connection by queueid; this allows us to tie the whole
    # lot together.
    if (exists $connection->{queueid}
            and not exists $queueids{$connection->{queueid}}) {
        $queueids{$connection->{queueid}} = $connection;
    }
}

sub track {
    my ($line, $rule, $matches) = @_;

    my $queueid         = get_queueid($line, $rule, $matches);
    my $connection      = get_connection_by_queueid($line, $queueid);

    my $results         = $connection->{results};
    my $child           = $results->[-1]->{child};
    if (not exists $connection->{children}) {
        $connection->{children} = {};
    }
    if (exists $connection->{children}->{$child}) {
        my_warn(qq{track: tracking $child for a second time:\n});
    }
    $connection->{children}->{$child} = 1;

    my $new_connection;
    if (exists $queueids{$child}) {
        $new_connection = $queueids{$child};
    } else {
        $new_connection = make_connection_by_queueid($line, $child);
    }
    # Clear the faked flag; we should never have committed a connection before
    # tracking now.
    delete $new_connection->{faked};

    # Mark both connections as tracked.
    $connection->{tracked}      = 1;
    $new_connection->{tracked}  = 1;

    if (exists $new_connection->{parent}
        and $new_connection->{parent} ne $queueid) {
        my_warn(qq{Trying to track for a second time! (parent differs)\n},
            qq{\tnew parent     => $queueid\n},
            qq{\tchild          => $child\n},
            qq{\told parent     => $new_connection->{parent}\n},
            qq{\t$line->{program}: $line->{text}\n},
        );
    }

    $new_connection->{parent} = $queueid;
}

# TODO: WRITE
# We commit unfaked, fixuped connections, regardless of parent/children -
# commit_connection() has nothing to do with that stuff.
sub commit_connection {
    my ($connection) = @_;

    if (exists $connection->{faked}) {
        my_warn(qq{commit_connection: faked connection: \n},
            dump_connection($connection)
        );
        return;
    }
    if (not exists $connection->{fixuped}) {
        my_warn(qq{commit_connection: un-fixuped connection: \n},
            dump_connection($connection)
        );
        return;
    }
    $connection->{committed} = 1;
}

sub my_warn {
    my ($first_line, @rest) = @_;
    my $prefix = qq{$0: $current_logfile: $.: };

    if (@rest) {
        # Make it easy to fold warnings
        my $newline = q{};
        if ($first_line =~ m/\n$/) {
            $newline = qq{\n};
            $first_line =~ s/\n$//;
        }
        warn $prefix, $first_line, q( {{{), $newline, @rest, qq(}}}\n);
    } else {
        warn $prefix, $first_line;
    }
}

sub my_die {
    die qq{$0: $current_logfile: $.: }, @_;
}

sub devel_profile_startup {
    if (exists $ENV{PERL_PROFILE_SAVETIME}) {
        DB::reset();
        my $filename;
        if (exists $ENV{PERL_PROFILE_FILENAME}) {
            $filename = $ENV{PERL_PROFILE_FILENAME};
        } else {
            $filename = q{prof.out};
        }
        rename $filename, qq{$filename.startup}
            or warn qq{$0: failed renaming $filename: $!\n};
    }
}

sub redirect_stdout {
    if (exists $ENV{REDIRECT_STDOUT}) {
        close STDOUT;
        open STDOUT, qq{> $ENV{REDIRECT_STDOUT}};
    }
}

__DATA__

sub save_connection {

    # We're not dealing with success; need to add that later.
    if (not exists $connections
        not @{$connections{$line->{pid}}->{results}}) {
        warn qq{$0: $logfile: $.: no results\n};
        delete $connections{$line->{pid}};
        return;
    }

    $connections{$line->{pid}}->{connection} =
        $dbix->resultset(q{Connection})->new_result({
            start => $line->{timestamp}
        });

        my $check_result = $dbix->resultset(q{Check::Result})->new_result({
            check_id        => $check->{id},
            result          => $result,
#                warning         => 
            smtp_code       => $smtp_code,
            recipient       => $matches[$check->{result_cols}->{recipient}],
            sender          => $matches[$check->{result_cols}->{sender}],
            log_line        => $line->{text},
            data            => $matches[$check->{result_cols}->{data}],
        });
    if ($num_connections_uncommitted > 1000) {
        $dbix->txn_commit();
        $num_connections_uncommitted = 0;
    }
    if (not $num_connections_uncommitted) {
        $dbix->txn_begin();
    }

    my $connection = $connections{$line->{pid}}->{connection};
    $connection->end($line->{timestamp});
    $connection->insert();
    $num_connections_uncommitted++;

    foreach my $result (@{$connections{$line->{pid}}->{results}}) {
        $result->connection_id($connection->id());
        $result->insert();
    }

}
