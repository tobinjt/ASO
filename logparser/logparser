#!/usr/bin/env perl

# $Id$

use strict;
use warnings;

use lib q{..};
use ASO::DB;
use Parse::Syslog;
use IO::File;
use Carp;
use Data::Dumper;

my $dbix = ASO::DB->connect(
    q{dbi:SQLite:dbname=../sql/db.sq3},
    {AutoCommit => 0},
);

my @logs = @ARGV;
if (not @logs and -t STDIN) {
    die qq{Usage: $0 logfile [logfiles]\n};
}
if (not @logs) {
    @logs = q{-};
}

my @checks      = process_checks();
my @parse_rules = process_parse_rules();

my %connections = ();
foreach my $logfile (@logs) {
    my $syslog = Parse::Syslog->new($logfile);
    if (not $syslog) {
        croak qq{Failed creating parser for $logfile: $@\n};
    }

    LINE:
    while (my $line = $syslog->next()) {
        if ($line->{program} !~ m/^postfix\/smtpd/) {
            # It's not from postfix, ignore it.
            next LINE;
        }
        if (not defined $line->{pid}) {
            # For some weird reason there's no PID.  Probably a line like:
            # "refreshing the Postfix mail system"
            next LINE;
        }

        RULE:
        foreach my $rule (@parse_rules) {
            if ($line->{text} !~ m/$rule->{regex}/) {
                next RULE;
            }

            # A line we want to ignore
            if (uc $rule->{action} eq q{IGNORE}) {
                next LINE;
            }

            # Someone has connected to us
            if (uc $rule->{action} eq q{CONNECT}) {
                if (exists $connections{$line->{pid}}) {
                    carp <<"COMPLAINT";
$0: $logfile: $.: existing connection hash for pid $line->{pid}; this should never happen :(
COMPLAINT
                    $connections{$line->{pid}} = {};
                } else {
                    $connections{$line->{pid}} = {};
                }
                next LINE;
            }

            # Someone has disconnected
            if (uc $rule->{action} eq q{DISCONNECT}) {
                if (not exists $connections{$line->{pid}}) {
                    carp <<"COMPLAINT";
$0: $logfile: $.: no connection hash for pid $line->{pid} - perhaps the connect line is in a previous log file?
COMPLAINT
                }
                delete $connections{$line->{pid}};
                next LINE;
            }
        }

        CHECK:
        foreach my $check (@checks) {
            my @matches = ($line->{text} =~ m/$check->{regex}/);
            if (not @matches) {
                next;
            }
            # regex matches are 1-based, but arrays are 0-based.
            # unshift undef onto the start of the array to align the two.
            unshift @matches, undef;
        }
        if ($line->{text} =~ m/^[A-Z0-9]{9}:/) {
            # Need to deal with this
            next;
        }
        if ($line->{text} =~ m/^NOQUEUE/) {
            # Need to deal with this
            next;
        }

        # Last ditch: complain to the user
        print qq{unknown line: $logfile: $.: $line->{text}\n};
    }
}

sub parse_result_cols {
    my ($spec) = @_;

    my $assignments = {};
    foreach my $assign (split /\s*;\s*/, $spec) {
        if (not length $assign) {
            croak qq{empty assignment found in: $assignments\n};
        }
        if ($assign !~ m/^\s*(\w+)\s*=\s*(\d+)\s*/) {
            croak qq{bad assignment: $assign\n};
        }
        $assignments->{$1} = $2;
    }
    return $assignments;
}

sub compile_regex {
    my ($object) = @_;
    my $regex = $object->regex();
    my $compiled_regex;
    eval {
        $compiled_regex = qr/$regex/;
    };
    if ($@) {
        my %columns = $object->get_columns();
        croak qq{$0: failed to compile regex $regex: $!\n}
            . Data::Dumper->Dump([\%columns], [qw(row)]);
    }
    return $compiled_regex;
}

sub process_parse_rules {
    my @results;
    foreach my $rule ($dbix->resultset(q{ParseRule})->search()) {
        my $rule_hash = {};
        $rule_hash->{id}                = $rule->id();
        $rule_hash->{action}            = $rule->action();
        $rule_hash->{rule_order}        = $rule->rule_order();
        # Compile the regex for efficiency, otherwise it'll be recompiled every
        # time it's used.
        $rule_hash->{regex}             = compile_regex($rule);
        push @results, $rule_hash;
    }
    return sort { $a->{rule_order} <=> $b->{rule_order} } @results;   
}

sub process_checks {
    my @results;
    foreach my $check ($dbix->resultset(q{Check})->search()) {
        my $check_hash = {};
        $check_hash->{id}               = $check->id();
        # Compile the regex for efficiency, otherwise it'll be recompiled every
        # time it's used.
        $check_hash->{regex}            = compile_regex($check);
        $check_hash->{result_cols}      = parse_result_cols($check->result_cols());
        $check_hash->{connection_cols}  
            = parse_result_cols($check->connection_cols());
        push @results, $check_hash;
    }
    return @results;
}
