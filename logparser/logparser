#!/usr/bin/env perl

# $Id$

use strict;
use warnings;
$| = 1;

use lib q{..};
use ASO::DB;
use ASO::Parser;
use Carp;

binmode STDOUT;
binmode STDERR;

sub timewarn {
    warn qq{$0: }, scalar localtime, q{: }, @_;
}

# Ensure that we don't try to read from a terminal.
my @logs = @ARGV;
if (not @logs and -t STDIN) {
    die qq{Usage: $0 logfile [logfiles]\n};
}
if (not @logs) {
    @logs = q{-};
}

# Save the startup times seperately, when profiling with Devel::Profile.
devel_profile_startup();

my $parser = ASO::Parser->new({
        data_source => q{dbi:SQLite:dbname=../sql/db.sq3},
        sort_rules  => q{normal},
        discard_compiled_regex  => 0,
        skip_inserting_results  => 1,
    });
warn qq{vim: set foldmethod=marker :\n};
# The main loop: most of it is really in parse_line(), to make profiling easier.
foreach my $logfile (@logs) {
    timewarn(qq{Starting to read $logfile\n});
    $parser->parse($logfile);
}

timewarn(qq{Updating rule_order\n});
$parser->update_check_order();

# Dump any remaining connections so we can tell when there are uncommitted
# mails; a lot of the time it's because someone is over quota, or a remote site
# is experiencing difficulties, but somethimes it's because we're not handling
# a sequence of events properly.
# In future we'll also use this to reload state from the previous run, to handle
# mails which cross logfile boundaries.
timewarn(qq{begin dumping state\n});
print $parser->dump_state();
timewarn(qq{finished dumping state\n});

# Some profiling modules dump their data to stdout, but we want to redirect
# that.  If the correct environment variable is set stdout will be redirected
# here and the data will go to the requested file.
redirect_stdout();

sub devel_profile_startup {
    if (exists $ENV{PERL_PROFILE_SAVETIME}) {
        DB::reset();
        my $filename;
        if (exists $ENV{PERL_PROFILE_FILENAME}) {
            $filename = $ENV{PERL_PROFILE_FILENAME};
        } else {
            $filename = q{prof.out};
        }
        rename $filename, qq{$filename.startup}
            or warn qq{$0: failed renaming $filename: $!\n};
    }
}

sub redirect_stdout {
    if (exists $ENV{REDIRECT_STDOUT}) {
        close STDOUT;
        open STDOUT, qq{> $ENV{REDIRECT_STDOUT}};
    }
}
