#!/usr/bin/env perl

# $Id$

use strict;
use warnings;

use lib q{..};
use ASO::DB;
use Parse::Syslog;
use IO::File;
use Carp;

my $dbix = ASO::DB->connect(
    q{dbi:SQLite:dbname=../sql/db.sq3},
    {AutoCommit => 0},
);

my @logs = @ARGV;
if (not @logs and -t STDIN) {
    die qq{Usage: $0 logfile [logfiles]\n};
}
if (not @logs) {
    @logs = q{-};
}

sub parse_result_cols {
    my ($spec) = @_;

    my $assignments = {};
    foreach my $assign (split /\s*;\s*/, $spec) {
        if (not length $assign) {
            croak qq{empty assignment found in: $assignments\n};
        }
        if ($assign !~ m/^\s*(\w+)\s*=\s*(\d+)\s*/) {
            croak qq{bad assignment: $assign\n};
        }
        $assignments->{$1} = $2;
    }
    return $assignments;
}

my @checks = ();
foreach my $check ($dbix->resultset(q{Check})->search()) {
    my $check_hash = {};
    $check_hash->{id}               = $check->();
    $check_hash->{regex}            = $check->();
    $check_hash->{result_cols}      = parse_result_cols($check->result_cols());
    $check_hash->{connection_cols}  
        = parse_result_cols($check->connection_cols());
    push @checks, $check_hash;
}

my %connections = ();

foreach my $logfile (@logs) {
    my $syslog = Parse::Syslog->new($logfile);
    if (not $syslog) {
        croak qq{Failed creating parser for $logfile: $@\n};
    }

    while (my $line = $syslog->next()) {
        if ($line->{program} !~ m/^postfix/) {
            # It's not from postfix, ignore it.
            next;
        }
        if (not defined $line->{pid}) {
            # For some weird reason there's no PID.  Probably a line like:
            # "refreshing the Postfix mail system"
            next;
        }
        if (not exists $connections{$line->{pid}}) {
            $connections{$line->{pid}} = {};
        }
        my $connection = $connections{$line->{pid}};

        my $text = $line->{text};
        if ($text =~ m/^[A-Z0-9]{9}:/) {
            # Need to deal with this
            next;
        }
        if ($text =~ m/^NOQUEUE/) {
            # Need to deal with this
            next;
        }

        # Someone is connecting
        # XXX: merge this with the check for non-existant connection hash
        if ($text =~ m/^connect/) {
            next;
        }

        # Various ways people can disconnect
        if ($text =~ m/^disconnect/) {
            # add record
            next;
        }
        if ($text =~ m/^lost connection after/) {
            # add record
            next;
        }
        if ($text =~ m/^timeout after (\w+|END-OF-MESSAGE) from /) {
            # add record
            next;
        }
        if ($text =~ m/^too many errors after \w+ from /) {
            # add record
            next;
        }

        # We can ignore these lines
        if ($text =~ m/^warning:/) {
            next;
        }
        if ($text =~ m/^statistics: /) {
            next;
        }
        if ($text =~ m/^table .* has changed -- restarting/) {
            next;
        }
        if ($text =~ m/^reload configuration/) {
            next;
        }

        # Last ditch: complain to the user
        print qq{$logfile: $.: $text\n};
    }
}


