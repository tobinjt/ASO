#!/usr/bin/env perl

# $Id$

use strict;
use warnings;

use DBI;
use IO::File;


my $DB = DBI->connect(
    q{dbi:SQLite:dbname=db.sq3},
    q{},
    q{},
    { 
        RaiseError => 1,
        AutoCommit => 0,
    }
);
if (not $DB) {
    die(qq{$0: Couldn't connect to database: } . $DBI::errstr . qq{\n});
}

$| = 1;
my $current_file;
my $line_number;
my $failures = 0;
my $current_block = q{};

READ:
while (<>) {
    # Initialise on the first iteration.
    if (not defined $current_file) {
        $current_file = $ARGV;
        $line_number = $.;
    }

    # Skip comment lines.
    if (m/^\s*--/) {
        next READ;
    }

    if ($current_file ne $ARGV) {
        # We've run off the end of the file
        run_sql($current_block);
        $current_block = $_;
        $current_file = $ARGV;
        $line_number = $.;
        next READ;
    }

    if (m/^\s*$/) {
        # End of the SQL paragraph.
        run_sql($current_block);
        $current_block = q{};
        $line_number = $. + 1;
    } else {
        $current_block .= $_;
    }
}

sub run_sql {
    my ($sql) = @_;
    if ($sql !~ m/\w/) {
        # Only empty lines, skip.
        return;
    }
#    print qq{running $sql};
    eval {
        # Warning!!!!  SQLite3 only runs the first command in the block of code,
        # ignoring any others there may be, so you need to separate them into
        # paragraphs.
        $DB->do($sql);
    };
    if ($@) {
        warn qq{Failed to run SQL: $ARGV: $line_number:\n},
             qq{error message: $DBI::errstr\n},
             qq{SQL: $sql};
        $failures++;
    }
}

if ($failures) {
    $DB->rollback();
} else {
    $DB->commit();
}
$DB->disconnect ();
exit $failures;
