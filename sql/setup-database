#!/usr/bin/env perl

# $Id$

use strict;
use warnings;

use DBI;
use IO::File;


my $DB = DBI->connect(
    q{dbi:SQLite:dbname=db.sq3},
    q{},
    q{},
    { 
        RaiseError => 1,
        AutoCommit => 0,
    }
);
if (not $DB) {
    die(qq{$0: Couldn't connect to database: } . $DBI::errstr . qq{\n});
}

$| = 1;
$/ = qq{\n\n};
my $line_number = 0;
my $current_file;
my $failures = 0;
while (<>) {
    #print qq{Read this chunk: \n$_ end of chunk\n\n\n};
    # Keep track of the line number; $. tracks lines as defined by $/, not
    # giving line numbers you'd expect in paragraph mode.
    if (not $current_file or $current_file ne $ARGV) {
        $current_file = $ARGV;
        $line_number = 0;
    }
    my $lines_this_chunk = 0;
    while (m/$/gm) {
        $lines_this_chunk++;
    }
    # We get one too many lines per chunk, so correct here.
    $lines_this_chunk--;

    # Try to skip comment only blocks
    s/^\s*--.*//gm;
    if (not m/../m) {
        $line_number += $lines_this_chunk;
        next;
    }
    #print qq{Trying the above block\n};

    eval {
        # Warning!!!!  SQLite3 only runs the first command in the block of code,
        # ignoring any others there may be, so you need to separate them into
        # paragraphs.
        $DB->do($_);
        $DB->commit();
    };
    if ($@) {
        warn qq{Failed to run SQL: $ARGV: $line_number:\n},
             qq{error message: $DBI::errstr\n},
             qq{SQL: $_};
        $failures++;
    }
    $line_number += $lines_this_chunk;
}

$DB->disconnect ();
exit $failures;
