#!/usr/bin/env perl

# $Id$

use strict;
use warnings;

use DBI;
use IO::File;
use Getopt::Long;
use Pod::Usage;

my $DB = DBI->connect(
    q{dbi:SQLite:dbname=db.sq3},
    q{},
    q{},
    { 
        RaiseError => 1,
        AutoCommit => 0,
    }
);
if (not $DB) {
    die(qq{$0: Couldn't connect to database: } . $DBI::errstr . qq{\n});
}

$| = 1;
my $current_file;
my $line_number;
my $failures = 0;
my $current_block = q{};

READ:
while (<>) {
    # Initialise on the first iteration.
    if (not defined $current_file) {
        $current_file = $ARGV;
        $line_number = $.;
    }

    # Skip comment lines.
    if (m/^\s*--/) {
        next READ;
    }

    if ($current_file ne $ARGV) {
        # We've run off the end of the file
        run_sql($current_block);
        $current_block = $_;
        $current_file = $ARGV;
        $line_number = $.;
        next READ;
    }

    if (m/^\s*$/) {
        # End of the SQL paragraph.
        run_sql($current_block);
        $current_block = q{};
        $line_number = $. + 1;
    } else {
        $current_block .= $_;
    }
} continue {
    if (eof) {
        # Close the current file when we reach the end of it to reset $.
        close ARGV;
    }
}


sub run_sql {
    my ($sql) = @_;
    if ($sql !~ m/\w/) {
        # Only empty lines, skip.
        return;
    }
#    print qq{running $sql};
    eval {
        # Warning!!!!  SQLite3 only runs the first command in the block of code,
        # ignoring any others there may be, so you need to separate them into
        # paragraphs.
        $DB->do($sql);
    };
    if ($@) {
        warn qq{Failed to run SQL: $ARGV: $line_number:\n},
             qq{error message: $DBI::errstr\n},
             qq{SQL: $sql};
        $failures++;
    }
}

if ($failures) {
    $DB->rollback();
} else {
    $DB->commit();
}
$DB->disconnect ();
exit $failures;

sub get_options {
    my %parser_options = (
        q{data_source=s}            => q{dbi:SQLite:dbname=../sql/db.sq3},
        q{sort_rules=s}             => q{normal},
        q{discard_compiled_regex!}  => 0,
        q{skip_inserting_results!}  => 0,
    );
    my %opts = (
        q{in-statefile|i=s}         => undef,
        q{out-statefile|o=s}        => q{state},
        q{help|h}                   => 0,
        q{version|v}                => 0,
        %parser_options,
    );

    my @switches    = keys %opts;
    %opts           = getopt_to_key(%opts);
    %parser_options = getopt_to_key(%parser_options);

    Getopt::Long::Configure qw(no_getopt_compat permute bundling);
    Getopt::Long::GetOptions(\%opts, @switches) or pod2usage(2);

    if ($opts{help}) {
        pod2usage(1);
    }
    if ($opts{version}) {
        my $version = q{$Id$};
        print qq{$0 version $version\n};
        exit 0;
    }

    map { $parser_options{$_} = $opts{$_}; } keys %parser_options;

    return (\%opts, \%parser_options);
}

